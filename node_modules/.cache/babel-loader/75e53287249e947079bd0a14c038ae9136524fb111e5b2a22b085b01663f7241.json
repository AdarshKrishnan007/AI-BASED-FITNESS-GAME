{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, util } from '@tensorflow/tfjs-core';\nimport { symbolicallyComputeStrides } from './shader_util';\nexport var PixelsOpType;\n(function (PixelsOpType) {\n  PixelsOpType[PixelsOpType[\"FROM_PIXELS\"] = 0] = \"FROM_PIXELS\";\n  PixelsOpType[PixelsOpType[\"DRAW\"] = 1] = \"DRAW\";\n})(PixelsOpType || (PixelsOpType = {}));\nexport const compileProgram = (device, program, inputsData, output, parallelCompilation) => {\n  const outputData = {\n    dtype: output.dtype,\n    shape: output.shape\n  };\n  const source = makeShader(inputsData, outputData, program);\n  const module = device.createShaderModule({\n    code: source,\n    label: program.constructor.name\n  });\n  let printShaderString = env().get('WEBGPU_PRINT_SHADER');\n  if (printShaderString !== '') {\n    printShaderString = printShaderString.toLowerCase();\n    const printShaderArray = printShaderString.split(',');\n    if (printShaderString === 'all' || printShaderArray.some(item => program.shaderKey.toLowerCase().includes(item))) {\n      console.group(program.shaderKey);\n      console.debug(source);\n      console.groupEnd();\n    }\n  }\n  if (parallelCompilation) {\n    return device.createComputePipelineAsync({\n      compute: {\n        module,\n        entryPoint: '_start'\n      },\n      label: program.constructor.name,\n      layout: 'auto'\n    });\n  } else {\n    return device.createComputePipeline({\n      compute: {\n        module,\n        entryPoint: '_start'\n      },\n      label: program.constructor.name,\n      layout: 'auto'\n    });\n  }\n};\nexport const typeSnippet = function (component) {\n  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'f32';\n  switch (component) {\n    case 1:\n      return \"\".concat(type);\n    case 2:\n      return \"vec2<\".concat(type, \">\");\n    case 3:\n      return \"vec3<\".concat(type, \">\");\n    case 4:\n      return \"vec4<\".concat(type, \">\");\n    default:\n      throw new Error(\"\".concat(component, \"-component \").concat(type, \" is not supported.\"));\n  }\n};\nexport function getCoordsDataType(rank) {\n  if (rank <= 1) {\n    return 'i32';\n  } else if (rank === 2) {\n    return \"vec2<i32>\";\n  } else if (rank === 3) {\n    return \"vec3<i32>\";\n  } else if (rank === 4) {\n    return \"vec4<i32>\";\n  } else if (rank === 5) {\n    return \"vec5\";\n  } else if (rank === 6) {\n    return \"vec6\";\n  } else {\n    throw Error(\"GPU for rank \".concat(rank, \" is not yet supported\"));\n  }\n}\nexport function getCoordsXYZ(index) {\n  if (index === 0) {\n    return 'x';\n  } else if (index === 1) {\n    return 'y';\n  } else if (index === 2) {\n    return 'z';\n  } else if (index === 3) {\n    return 'w';\n  } else if (index === 4) {\n    return 'u';\n  } else if (index === 5) {\n    return 'v';\n  } else {\n    throw Error(\"Index \".concat(index, \" is not yet supported\"));\n  }\n}\nexport function getMainHeaderString() {\n  let snippet;\n  switch (arguments.length) {\n    case 0:\n      snippet = \"\\n        fn main()\\n      \";\n      break;\n    case 1:\n      snippet = \"\\n        fn main(\".concat(arguments.length <= 0 ? undefined : arguments[0], \" : i32)\\n      \");\n      break;\n    default:\n      throw Error('Unreachable');\n  }\n  return snippet;\n}\nexport function getStartHeaderString(useGlobalIndex, program) {\n  let snippet;\n  snippet = \"\\n     \".concat(getWorkgroupSizeString(program), \"\\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\\n                @builtin(local_invocation_index) LocalIndex: u32,\\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\\n        localId = LocalId;\\n        localIndex = LocalIndex;\\n        globalId = GlobalId;\\n        numWorkgroups = NumWorkgroups;\\n        workgroupId = WorkgroupId;\\n        \").concat(useGlobalIndex ? \"main(getGlobalIndex());\" : \"main();\", \";\\n      }\\n    \");\n  return snippet;\n}\nexport function getWorkgroupSizeString(program) {\n  return \"\\n  @compute @workgroup_size(\".concat(program.workgroupSize[0], \", \").concat(program.workgroupSize[1], \", \").concat(program.workgroupSize[2], \")\\n\");\n}\nfunction makeShader(inputInfo, outputData, program) {\n  const prefixSnippets = [];\n  const flatWorkgroupSize = program.workgroupSize[0] * program.workgroupSize[1] * program.workgroupSize[2];\n  program.outputComponent = program.outputComponent ? program.outputComponent : 1;\n  prefixSnippets.push(\"\\n\\n      var<private> localId: vec3<u32>;\\n      var<private> localIndex: u32;\\n      var<private> globalId: vec3<u32>;\\n      var<private> numWorkgroups: vec3<u32>;\\n      var<private> workgroupId: vec3<u32>;\\n\\n      // Only used when the y/z dimension of workgroup size is 1.\\n      fn getGlobalIndex() -> i32 {\\n        \".concat(isFlatDispatch(program) ? \"  return i32(globalId.x);\" : \"  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * \".concat(flatWorkgroupSize, \"u +\\n                localIndex);\\n        \"), \"\\n      }\\n    \"));\n  if (program.pixelsOpType != null) {\n    const inoutSnippet = program.pixelsOpType === PixelsOpType.FROM_PIXELS ? \"@group(0) @binding(0) var<storage, read_write> result: array<\".concat(dataTypeToGPUType(outputData.dtype, program.outputComponent), \">;\") : \"@group(0) @binding(1) var<storage, read> inBuf : array<\".concat(dataTypeToGPUType(inputInfo[0].dtype, program.outputComponent), \">;\");\n    const outShapeStridesType = outputData.shape.length === 3 ? 'vec2<i32>' : 'i32';\n    prefixSnippets.push(\"\\n        struct Uniform {\\n          outShapeStrides : \".concat(outShapeStridesType, \",\\n          size            : i32,\\n          numChannels     : i32,\\n          alpha           : f32,\\n        };\\n\\n        \").concat(inoutSnippet, \"\\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\\n      \"));\n    const useGlobalIndex = isFlatDispatchLayout(program);\n    return [commonSnippet, prefixSnippets.join('\\n'), getCoordsFromIndexSnippet(outputData.shape), program.getUserCode(), getStartHeaderString(useGlobalIndex, program)].join('\\n');\n  }\n  let stridesLength;\n  let stridesDataType;\n  let uniformDeclaration = 'struct Uniforms { NAN : f32, INFINITY : f32, ';\n  program.variableNames.forEach((x, i) => {\n    const perDataType = getCoordsDataType(inputInfo[i].shape.length);\n    uniformDeclaration += \"\".concat(x.charAt(0).toLowerCase() + x.slice(1), \"Shape : \").concat(perDataType, \", \");\n    stridesLength = inputInfo[i].shape.length - 1;\n    stridesDataType = getCoordsDataType(stridesLength);\n    uniformDeclaration += \"\".concat(x.charAt(0).toLowerCase() + x.slice(1), \"ShapeStrides: \").concat(stridesDataType, \", \");\n  });\n  const outputDataType = getCoordsDataType(outputData.shape.length);\n  uniformDeclaration += \"outShape : \".concat(outputDataType, \", \");\n  stridesLength = outputData.shape.length - 1;\n  stridesDataType = getCoordsDataType(stridesLength);\n  uniformDeclaration += \"\\n         outShapeStrides: \".concat(stridesDataType, \", \");\n  if (program.size) {\n    uniformDeclaration += 'size : i32, ';\n  }\n  if (program.uniforms) {\n    uniformDeclaration += program.uniforms;\n  }\n  uniformDeclaration += '};';\n  uniformDeclaration = insertAlignment(uniformDeclaration);\n  prefixSnippets.push(uniformDeclaration);\n  // Output buffer.\n  if (program.atomic) {\n    prefixSnippets.push(\"\\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\\n    \");\n  } else {\n    prefixSnippets.push(\"\\n      @group(0) @binding(0) var<storage, read_write> result: array<\".concat(dataTypeToGPUType(outputData.dtype, program.outputComponent), \">;\\n    \"));\n  }\n  program.variableNames.forEach((x, i) => {\n    prefixSnippets.push(\"\\n      @group(0) @binding(\".concat(1 + i, \") var<storage, read> \").concat(x, \": array<\").concat(program.variableComponents ? dataTypeToGPUType(inputInfo[i].dtype, program.variableComponents[i]) : dataTypeToGPUType(inputInfo[i].dtype, program.outputComponent), \">;\\n        \"));\n  });\n  if (uniformDeclaration !== '') {\n    prefixSnippets.push(\"\\n      @group(0) @binding(\".concat(1 + program.variableNames.length, \") var<uniform> uniforms: Uniforms;\\n      \"));\n  }\n  const coordsSnippet = getOutputCoordsSnippet(outputData.shape, program.dispatchLayout);\n  const sources = [commonSnippet, prefixSnippets.join('\\n') + isInfSnippet, getCoordsFromIndexSnippet(outputData.shape), coordsSnippet, getOutputIndexFromCoordsSnippet(outputData.shape.length)];\n  if (!program.atomic) {\n    sources.push(setOutputSnippet(outputData.shape, outputData.dtype, program.outputComponent));\n  }\n  program.variableNames.forEach((x, i) => {\n    sources.push(\"\".concat(getCoordsFromIndexSnippet(inputInfo[i].shape, x)));\n  });\n  const inputSnippet = inputInfo.map((x, i) => getInputSnippet(x, outputData.shape, program.variableComponents ? program.variableComponents[i] : program.outputComponent, program.dispatchLayout.x.length === outputData.shape.length)).join('\\n');\n  sources.push(inputSnippet);\n  sources.push(program.getUserCode());\n  const useGlobalIndex = isFlatDispatchLayout(program);\n  sources.push(getStartHeaderString(useGlobalIndex, program));\n  const source = sources.join('\\n');\n  return source;\n}\nexport function makeShaderKey(program, inputsData, output) {\n  let key = program.shaderKey;\n  if (program.pixelsOpType != null) {\n    return key;\n  }\n  const shapes = [];\n  const types = [];\n  inputsData.forEach(element => {\n    shapes.push(element.shape);\n    types.push(element.dtype);\n  });\n  shapes.push(output.shape);\n  types.push(output.dtype);\n  const broadcastDims = inputsData.map(d => backend_util.getBroadcastDims(d.shape, output.shape));\n  const inputShapesEqualsOutShape = inputsData.map(d => util.arraysEqual(d.shape, output.shape)).join('_');\n  const broadcastDimsKey = broadcastDims.map(d => d.join('_')).join(';');\n  const flatDispatchString = isFlatDispatch(program) ? 'flatDispatch' : '';\n  key += '_' + (program.workgroupSize ? program.workgroupSize.join(',') : '') + shapes.map(shape => shape.length).join(',') + types.join(',') + program.variableNames.join(',') + broadcastDimsKey + inputShapesEqualsOutShape + flatDispatchString;\n  return key;\n}\nconst commonSnippet = \"\\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\\n\\n  // Checks whether coordinates lie within the bounds of the shape.\\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\\n  }\\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\\n  }\\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\\n  }\\n\\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\\n    return coord;\\n  }\\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\\n    return dot(coords, vec2<i32>(shape.y, 1));\\n  }\\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\\n  }\\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\\n    return dot(coords, vec4<i32>(\\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\\n  }\\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\\n  }\\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\\n  }\\n\\n  // NaN defination in IEEE 754-1985 is :\\n  //   - sign = either 0 or 1.\\n  //   - biased exponent = all 1 bits.\\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\\n  fn isnan(val: f32) -> bool {\\n    let floatToUint: u32 = bitcast<u32>(val);\\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\\n  }\\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\\n  }\\n\";\nconst isInfSnippet = \"\\n  fn isinf(val: f32) -> bool {\\n    return abs(val) == uniforms.INFINITY;\\n  }\\n\";\n/**\n * Derives logical coordinates from a flat index. Performs integer division\n * with each stride and decrements the index until the index equals the final\n * dimension coordinate.\n */\nexport function getCoordsFromIndexSnippet(shape) {\n  let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  const rank = shape.length;\n  const funcName = name !== '' ? \"get\".concat(name.charAt(0).toUpperCase() + name.slice(1), \"CoordsFromIndex\") : 'getCoordsFromIndex';\n  const stridesName = name !== '' ? \"\".concat(name.charAt(0).toLowerCase() + name.slice(1), \"ShapeStrides\") : \"outShapeStrides\";\n  if (rank <= 1) {\n    return \"fn \".concat(funcName, \"(index : i32) -> i32 { return index; }\");\n  }\n  const strides = util.computeStrides(shape);\n  const dtype = getCoordsDataType(rank);\n  const coords = [];\n  for (let i = 0; i < rank; i++) {\n    coords.push(\"d\".concat(i));\n  }\n  if (strides.length === 1) {\n    return \"    fn \".concat(funcName, \"(index : i32) -> vec2<i32> {\\n      let d0 = index / uniforms.\").concat(stridesName, \"; let d1 = index - d0 * uniforms.\").concat(stridesName, \";\\n      return vec2<i32>(d0, d1);\\n    }\");\n  }\n  let snippet;\n  snippet = 'var index2 = index;' + strides.map((_, i) => {\n    const line1 = \"let \".concat(coords[i], \" = index2 / uniforms.\").concat(stridesName, \".\").concat(getCoordsXYZ(i));\n    const line2 = i === strides.length - 1 ? \"let \".concat(coords[i + 1], \" = index2 - \").concat(coords[i], \" * uniforms.\").concat(stridesName, \".\").concat(getCoordsXYZ(i)) : \"index2 = index2 - \".concat(coords[i], \" * uniforms.\").concat(stridesName, \".\").concat(getCoordsXYZ(i));\n    return \"\".concat(line1, \"; \").concat(line2, \";\");\n  }).join('');\n  return \"\\n    fn \".concat(funcName, \"(index : i32) -> \").concat(dtype, \" {\\n      \").concat(snippet, \"\\n      return \").concat(dtype, \"(\").concat(coords.join(','), \");\\n    }\\n  \");\n}\nfunction getInputAtCoordsSnippet(inputInfo, component) {\n  const texName = inputInfo.name;\n  const rank = inputInfo.shape.length;\n  const type = getCoordsDataType(rank);\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, rank);\n  const inputs = dims.map(d => \"\".concat(d, \" : i32\")).join(', ');\n  if (rank < 1) {\n    return \"\\n      fn \".concat(funcName, \"() -> \").concat(typeSnippet(component), \" {\\n        return \").concat(typeSnippet(component), \"(\").concat(texName, \"[0]);\\n      }\\n    \");\n  }\n  const shapeStr = \"uniforms.\".concat(texName.charAt(0).toLowerCase() + texName.slice(1), \"Shape\");\n  let rankStr = \"\".concat(rank, \"D\");\n  if (rank === 0) {\n    rankStr = '1D';\n  }\n  return \"\\n    fn \".concat(funcName, \"(\").concat(inputs, \") -> \").concat(typeSnippet(component), \" {\\n      return \").concat(typeSnippet(component), \"(\").concat(texName, \"[getIndexFromCoords\").concat(rankStr, \"(\").concat(type, \"(\").concat(dims.join(','), \"),\\n        \").concat(shapeStr, \")\").concat(component === 1 ? '' : \" / \".concat(component), \"]);\\n    }\\n   \");\n}\nfunction getInputByOutputSnippet(inputInfo, outShape, component, isFlatDispatchLayout) {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n  const funcName = 'get' + texFuncSnippet + 'ByOutput';\n  const inRank = inputInfo.shape.length;\n  const outRank = outShape.length;\n  const type = getCoordsDataType(outRank);\n  // If the inShape equals the outShape and the dispatch layout is flat, we can\n  // directly use |gl_GlobalInvocationID.x| as the index and don't need coords\n  // conversion between these two shapes.\n  if (util.arraysEqual(inputInfo.shape, outShape) && isFlatDispatchLayout) {\n    return \"\\n    fn \".concat(funcName, \"Index(globalIndex : i32) -> \").concat(typeSnippet(component), \" {\\n      return \").concat(typeSnippet(component), \"(\").concat(texName, \"[globalIndex]);\\n    }\\n\\n    fn \").concat(funcName, \"Coords(coords : \").concat(type, \") -> \").concat(typeSnippet(component), \" {\\n      return \").concat(typeSnippet(component), \"(\").concat(texName, \"[\").concat(outRank > 1 ? 'getOutputIndexFromCoords(coords)' : 'coords').concat(component === 1 ? '' : \" / \".concat(component), \"]);\\n    }\\n    \");\n  }\n  const broadcastDims = backend_util.getBroadcastDims(inputInfo.shape, outShape);\n  const rankDiff = outRank - inRank;\n  let coordsSnippet = '';\n  if (inRank === 0) {\n    return \"\\n    fn \".concat(funcName, \"Index(globalIndex : i32) -> \").concat(typeSnippet(component), \"{\\n      return get\").concat(texFuncSnippet, \"();\\n    }\\n\\n    fn \").concat(funcName, \"Coords(coords : \").concat(type, \") -> \").concat(typeSnippet(component), \"{\\n      return get\").concat(texFuncSnippet, \"();\\n    }\\n  \");\n  } else {\n    if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet = broadcastDims.map(d => \"coords.\".concat(getCoordsXYZ(d + rankDiff), \" = 0;\")).join('\\n');\n    }\n  }\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    if (outRank > 1) {\n      const coordsType = getCoordsDataType(inRank);\n      const coordsValues = inputInfo.shape.map((s, i) => \"coords.\".concat(getCoordsXYZ(i + rankDiff))).join(', ');\n      unpackedCoordsSnippet = \"\".concat(coordsType, \"(\").concat(coordsValues, \")\");\n    } else {\n      unpackedCoordsSnippet = 'coords';\n    }\n  }\n  const shapeStr = \"uniforms.\".concat(texName.charAt(0).toLowerCase() + texName.slice(1), \"Shape\");\n  const rankStr = \"\".concat(inRank, \"D\");\n  return \"\\n  fn \".concat(funcName, \"Index(globalIndex : i32) -> \").concat(typeSnippet(component), \" {\\n    var coords = getCoordsFromIndex(globalIndex);\\n    \").concat(coordsSnippet, \"\\n    return \").concat(typeSnippet(component), \"(\").concat(texName, \"[getIndexFromCoords\").concat(rankStr, \"(\").concat(unpackedCoordsSnippet, \", \").concat(shapeStr, \")\").concat(component === 1 ? '' : \" / \".concat(component), \"]);\\n  }\\n\\n  fn \").concat(funcName, \"Coords(coordsIn : \").concat(type, \") -> \").concat(typeSnippet(component), \" {\\n    var coords = coordsIn;\\n    \").concat(coordsSnippet, \"\\n    return \").concat(typeSnippet(component), \"(\").concat(texName, \"[getIndexFromCoords\").concat(rankStr, \"(\").concat(unpackedCoordsSnippet, \", \").concat(shapeStr, \")\").concat(component === 1 ? '' : \" / \".concat(component), \"]);\\n  }\\n\");\n}\nfunction getInputSnippet(inputInfo, outShape, component, isFlatDispatchLayout) {\n  let res = getInputAtCoordsSnippet(inputInfo, component);\n  const inShape = inputInfo.shape;\n  if (inShape.length <= outShape.length) {\n    res += getInputByOutputSnippet(inputInfo, outShape, component, isFlatDispatchLayout);\n  }\n  return res;\n}\n/**\n * Generates getOutputCoords() function that computes output coordinates\n * from dispatch geometry to reduce arithmetic.\n */\nfunction getOutputCoordsSnippet(outShape, dispatchLayout) {\n  const {\n    x,\n    y = [],\n    z = []\n  } = dispatchLayout;\n  const outRank = outShape.length;\n  const rank = x.length + y.length + z.length;\n  // getOutputCoords is only meaningful when the output rank is same with\n  // dispatch layout rank.\n  if (rank !== outRank) {\n    return '';\n  }\n  if (x.length === outRank) {\n    const dtype = getCoordsDataType(outRank);\n    const snippet = \"fn getOutputCoords() -> \".concat(dtype, \"{\\n    let globalIndex = getGlobalIndex();\\n    return getCoordsFromIndex(globalIndex);\\n  }\\n  \");\n    return snippet;\n  }\n  let gatherDimensionsStr = '';\n  const dims = [x, y, z];\n  for (let i = 0; i < dims.length; i++) {\n    const arr = dims[i];\n    if (arr.length === 0) {\n      continue;\n    }\n    if (arr.length === 1) {\n      gatherDimensionsStr += \"let d\".concat(arr[0], \" = i32(globalId[\").concat(i, \"]);\");\n    } else {\n      const strides = symbolicallyComputeStrides(arr, 'uniforms.outShape');\n      gatherDimensionsStr += \"var index\".concat(i, \" = i32(globalId[\").concat(i, \"]);\");\n      for (let j = 0; j < strides.length; j++) {\n        gatherDimensionsStr += \"let d\".concat(arr[j], \" = index\").concat(i, \" / \").concat(strides[j], \";\");\n        if (j === strides.length - 1) {\n          gatherDimensionsStr += \"let d\".concat(arr[j + 1], \" = \") + \"index\".concat(i, \" - d\").concat(arr[j], \" * \").concat(strides[j], \";\");\n        } else {\n          gatherDimensionsStr += \"index\".concat(i, \" = index\").concat(i, \" - d\").concat(arr[j], \" * \").concat(strides[j], \";\");\n        }\n      }\n    }\n  }\n  const dimensions = [];\n  for (let i = 0; i < rank; i++) {\n    dimensions.push(\"d\".concat(i));\n  }\n  const dtype = getCoordsDataType(rank);\n  let snippet = \"fn getOutputCoords() -> \".concat(dtype, \" {\\n  \").concat(gatherDimensionsStr, \"\\n\");\n  if (dimensions.length === 0) {\n    snippet += \"return \".concat(dtype, \"(0); }\");\n  } else {\n    snippet += \"return \".concat(dtype, \"(\").concat(dimensions.join(','), \"); }\");\n  }\n  return snippet;\n}\nfunction getOutputIndexFromCoordsSnippet(outRank) {\n  let snippet = '';\n  switch (outRank) {\n    case 0:\n    case 1:\n      snippet += \"\\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\\n          return coords;\\n        }\\n        \";\n      break;\n    case 2:\n      snippet += \"\\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\\n        }\\n        \";\n      break;\n    case 3:\n      snippet += \"\\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\\n        }\\n        \";\n      break;\n    case 4:\n      snippet += \"\\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\\n          return dot(coords, vec4<i32>(\\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\\n        }\\n        \";\n      break;\n    case 5:\n      snippet += \"\\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\\n          return coords.x * uniforms.outShapeStrides.x +\\n              coords.y * uniforms.outShapeStrides.y +\\n              coords.z * uniforms.outShapeStrides.z +\\n              coords.w * uniforms.outShapeStrides.w +\\n              coords.u;\\n        }\\n        \";\n      break;\n    case 6:\n      snippet += \"\\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\\n          return coords.x * uniforms.outShapeStrides.x +\\n              coords.y * uniforms.outShapeStrides.y +\\n              coords.z * uniforms.outShapeStrides.z +\\n              coords.w * uniforms.outShapeStrides.w +\\n              coords.u * uniforms.outShapeStrides.u +\\n              coords.v;\\n        }\\n        \";\n      break;\n    default:\n      util.assert(false, () => \"Unsupported \".concat(outRank, \"D shape\"));\n      break;\n  }\n  return snippet;\n}\nfunction isFlatDispatch(program) {\n  return program.dispatch[1] === 1 && program.dispatch[2] === 1;\n}\nexport function dataTypeToGPUType(type) {\n  let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (type === 'float32') {\n    return typeSnippet(component, 'f32');\n  } else if (type === 'int32' || type === 'bool') {\n    return typeSnippet(component, 'i32');\n  }\n  throw new Error(\"type \".concat(type, \" is not supported.\"));\n}\nfunction setOutputSnippet(outShape, outBufferType, component) {\n  const outRank = outShape.length;\n  const gpuType = dataTypeToGPUType(outBufferType, component);\n  let snippet = \"fn setOutputAtIndex(flatIndex : i32, value : \".concat(typeSnippet(component), \") {\\n      result[flatIndex] = \").concat(gpuType, \"(value);\\n    }\\n\\n    fn setOutputAtIndexI32(flatIndex : i32, value : \").concat(typeSnippet(component, 'i32'), \") {\\n      result[flatIndex] = \").concat(gpuType, \"(value);\\n    }\\n    \");\n  if (outRank >= 2) {\n    const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, outRank);\n    const type = getCoordsDataType(outRank);\n    snippet += \"\\n      fn setOutputAtCoords(\".concat(dims.map(d => \"\".concat(d, \" : i32\")).join(', '), \", value : \").concat(typeSnippet(component), \") {\\n        let flatIndex = getOutputIndexFromCoords(\").concat(type, \"(\").concat(dims.join(', '), \"));\\n        setOutputAtIndex(flatIndex\").concat(component === 1 ? '' : \" / \".concat(component), \", value);\\n      }\\n      fn setOutputAtCoordsI32(\").concat(dims.map(d => \"\".concat(d, \" : i32\")).join(', '), \", value : \").concat(typeSnippet(component, 'i32'), \") {\\n        let flatIndex = getOutputIndexFromCoords(\").concat(type, \"(\").concat(dims.join(', '), \"));\\n        setOutputAtIndexI32(flatIndex\").concat(component === 1 ? '' : \" / \".concat(component), \", value);\\n      }\\n    \");\n  }\n  return snippet;\n}\nfunction insertAlignment(uniformShader) {\n  // insert alignment when current pattern is vec5 or vec6\n  const curInsertRe = /(\\w+)\\s*:\\s*vec(5|6)/g;\n  uniformShader = uniformShader.replace(curInsertRe, match => {\n    return '@align(16) ' + match;\n  });\n  // insert alignment when previous pattern is vec5 or vec6\n  const preInsertRe = /vec(5|6)\\s*,\\s*(\\w+)/g;\n  uniformShader = uniformShader.replace(preInsertRe, (_, p1, p2) => {\n    return \"vec\".concat(p1, \", @align(16) \").concat(p2);\n  });\n  return uniformShader;\n}\nfunction isFlatDispatchLayout(program) {\n  if (program.dispatchLayout.hasOwnProperty('y') && program.dispatchLayout.y.length !== 0) {\n    return false;\n  }\n  if (program.dispatchLayout.hasOwnProperty('z') && program.dispatchLayout.z.length !== 0) {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["backend_util","env","util","symbolicallyComputeStrides","PixelsOpType","compileProgram","device","program","inputsData","output","parallelCompilation","outputData","dtype","shape","source","makeShader","module","createShaderModule","code","label","constructor","name","printShaderString","get","toLowerCase","printShaderArray","split","some","item","shaderKey","includes","console","group","debug","groupEnd","createComputePipelineAsync","compute","entryPoint","layout","createComputePipeline","typeSnippet","component","type","arguments","length","undefined","concat","Error","getCoordsDataType","rank","getCoordsXYZ","index","getMainHeaderString","snippet","getStartHeaderString","useGlobalIndex","getWorkgroupSizeString","workgroupSize","inputInfo","prefixSnippets","flatWorkgroupSize","outputComponent","push","isFlatDispatch","pixelsOpType","inoutSnippet","FROM_PIXELS","dataTypeToGPUType","outShapeStridesType","isFlatDispatchLayout","commonSnippet","join","getCoordsFromIndexSnippet","getUserCode","stridesLength","stridesDataType","uniformDeclaration","variableNames","forEach","x","i","perDataType","charAt","slice","outputDataType","size","uniforms","insertAlignment","atomic","variableComponents","coordsSnippet","getOutputCoordsSnippet","dispatchLayout","sources","isInfSnippet","getOutputIndexFromCoordsSnippet","setOutputSnippet","inputSnippet","map","getInputSnippet","makeShaderKey","key","shapes","types","element","broadcastDims","d","getBroadcastDims","inputShapesEqualsOutShape","arraysEqual","broadcastDimsKey","flatDispatchString","funcName","toUpperCase","stridesName","strides","computeStrides","coords","_","line1","line2","getInputAtCoordsSnippet","texName","dims","inputs","shapeStr","rankStr","getInputByOutputSnippet","outShape","texFuncSnippet","inRank","outRank","rankDiff","unpackedCoordsSnippet","coordsType","coordsValues","s","res","inShape","y","z","gatherDimensionsStr","arr","j","dimensions","assert","dispatch","outBufferType","gpuType","uniformShader","curInsertRe","replace","match","preInsertRe","p1","p2","hasOwnProperty"],"sources":["D:\\Fitness WebApp\\tfjs-backend-webgpu\\src\\webgpu_program.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, DataTypeMap, env, Rank, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {symbolicallyComputeStrides} from './shader_util';\n\nexport enum PixelsOpType {\n  FROM_PIXELS,\n  DRAW\n}\n\nexport interface WebGPUProgram {\n  // Whether to use atomic built-in functions.\n  atomic?: boolean;\n  // dispatch specifies geometry of thread groups - derived from dispatchLayout.\n  dispatch: [number, number, number];\n  // dispatchLayout enumerates how tensor dimensions are distributed among\n  // dispatch x,y,z dimensions.\n  dispatchLayout: {x: number[], y?: number[], z?: number[]};\n  // By default, the output data component is 1.\n  outputComponent?: number;\n  outputShape: number[];\n  pixelsOpType?: PixelsOpType;\n  // The unique key to distinguish different shader source code.\n  shaderKey: string;\n  // Whether to use output size for bounds checking.\n  size?: boolean;\n  uniforms?: string;\n  variableNames: string[];\n  // Describe each variable's component and must have one-one mapping with\n  // variableNames. If not set, all variables component will be same with output\n  // component member.\n  variableComponents?: number[];\n  // workgroupSize.x * workgroupSize.y * workgroupSize.z = the number of threads\n  // in a thread group. Individual dimensions determines thread layout within\n  // the group.\n  workgroupSize: [number, number, number];\n  // Size of register cache in one dimension (assumes square cache).\n  // Each thread writes to workPerThread * workPerThread locations in the output\n  // buffer.\n  workPerThread?: number;\n  pipeline?: GPUComputePipeline|Promise<GPUComputePipeline>;\n  getUserCode: () => string;\n}\n\nexport const compileProgram =\n    (device: GPUDevice, program: WebGPUProgram, inputsData: InputInfo[],\n     output: TensorInfo, parallelCompilation: boolean): GPUComputePipeline|\n    Promise<GPUComputePipeline> => {\n      const outputData = {dtype: output.dtype, shape: output.shape};\n      const source = makeShader(inputsData, outputData, program);\n      const module = device.createShaderModule(\n          {code: source, label: program.constructor.name});\n\n      let printShaderString = env().get('WEBGPU_PRINT_SHADER') as string;\n      if (printShaderString !== '') {\n        printShaderString = printShaderString.toLowerCase();\n        const printShaderArray = printShaderString.split(',');\n        if (printShaderString === 'all' ||\n            printShaderArray.some(\n                item => program.shaderKey.toLowerCase().includes(item))) {\n          console.group(program.shaderKey);\n          console.debug(source);\n          console.groupEnd();\n        }\n      }\n\n      if (parallelCompilation) {\n        return device.createComputePipelineAsync({\n          compute: {module, entryPoint: '_start'},\n          label: program.constructor.name,\n          layout: 'auto'\n        });\n      } else {\n        return device.createComputePipeline({\n          compute: {module, entryPoint: '_start'},\n          label: program.constructor.name,\n          layout: 'auto'\n        });\n      }\n    };\n\nexport const typeSnippet = (component: number, type = 'f32') => {\n  switch (component) {\n    case 1:\n      return `${type}`;\n    case 2:\n      return `vec2<${type}>`;\n    case 3:\n      return `vec3<${type}>`;\n    case 4:\n      return `vec4<${type}>`;\n    default:\n      throw new Error(`${component}-component ${type} is not supported.`);\n  }\n};\n\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'i32';\n  } else if (rank === 2) {\n    return `vec2<i32>`;\n  } else if (rank === 3) {\n    return `vec3<i32>`;\n  } else if (rank === 4) {\n    return `vec4<i32>`;\n  } else if (rank === 5) {\n    return `vec5`;\n  } else if (rank === 6) {\n    return `vec6`;\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\nexport function getCoordsXYZ(index: number): string {\n  if (index === 0) {\n    return 'x';\n  } else if (index === 1) {\n    return 'y';\n  } else if (index === 2) {\n    return 'z';\n  } else if (index === 3) {\n    return 'w';\n  } else if (index === 4) {\n    return 'u';\n  } else if (index === 5) {\n    return 'v';\n  } else {\n    throw Error(`Index ${index} is not yet supported`);\n  }\n}\n\nexport function getMainHeaderString(): string;\nexport function getMainHeaderString(index: string): string;\nexport function getMainHeaderString(...params: string[]): string {\n  let snippet: string;\n  switch (params.length) {\n    case 0:\n      snippet = `\n        fn main()\n      `;\n      break;\n    case 1:\n      snippet = `\n        fn main(${params[0]} : i32)\n      `;\n      break;\n    default:\n      throw Error('Unreachable');\n  }\n  return snippet;\n}\n\nexport function getStartHeaderString(\n    useGlobalIndex: boolean, program: WebGPUProgram): string {\n  let snippet: string;\n  snippet = `\n     ${getWorkgroupSizeString(program)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${useGlobalIndex ? `main(getGlobalIndex());` : `main();`};\n      }\n    `;\n  return snippet;\n}\n\nexport function getWorkgroupSizeString(program: WebGPUProgram): string {\n  return `\n  @compute @workgroup_size(${program.workgroupSize[0]}, ${\n      program.workgroupSize[1]}, ${program.workgroupSize[2]})\n`;\n}\n\nfunction makeShader(\n    inputInfo: InputInfo[], outputData: {dtype: DataType, shape: number[]},\n    program: WebGPUProgram): string {\n  const prefixSnippets: string[] = [];\n  const flatWorkgroupSize = program.workgroupSize[0] *\n      program.workgroupSize[1] * program.workgroupSize[2];\n  program.outputComponent =\n      program.outputComponent ? program.outputComponent : 1;\n  prefixSnippets.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${\n      isFlatDispatch(program) ?\n          `  return i32(globalId.x);` :\n          `  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${\n              flatWorkgroupSize}u +\n                localIndex);\n        `}\n      }\n    `);\n\n  if (program.pixelsOpType != null) {\n    const inoutSnippet = program.pixelsOpType === PixelsOpType.FROM_PIXELS ?\n        `@group(0) @binding(0) var<storage, read_write> result: array<${\n            dataTypeToGPUType(outputData.dtype, program.outputComponent)}>;` :\n        `@group(0) @binding(1) var<storage, read> inBuf : array<${\n            dataTypeToGPUType(inputInfo[0].dtype, program.outputComponent)}>;`;\n    const outShapeStridesType =\n        outputData.shape.length === 3 ? 'vec2<i32>' : 'i32';\n    prefixSnippets.push(`\n        struct Uniform {\n          outShapeStrides : ${outShapeStridesType},\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ${inoutSnippet}\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);\n    const useGlobalIndex = isFlatDispatchLayout(program);\n    return [\n      commonSnippet,\n      prefixSnippets.join('\\n'),\n      getCoordsFromIndexSnippet(outputData.shape),\n      program.getUserCode(),\n      getStartHeaderString(useGlobalIndex, program),\n    ].join('\\n');\n  }\n\n  let stridesLength: number;\n  let stridesDataType: string;\n  let uniformDeclaration = 'struct Uniforms { NAN : f32, INFINITY : f32, ';\n  program.variableNames.forEach((x, i) => {\n    const perDataType = getCoordsDataType(inputInfo[i].shape.length);\n    uniformDeclaration +=\n        `${x.charAt(0).toLowerCase() + x.slice(1)}Shape : ${perDataType}, `;\n    stridesLength = inputInfo[i].shape.length - 1;\n    stridesDataType = getCoordsDataType(stridesLength);\n    uniformDeclaration +=\n        `${x.charAt(0).toLowerCase() + x.slice(1)}ShapeStrides: ${\n            stridesDataType}, `;\n  });\n  const outputDataType = getCoordsDataType(outputData.shape.length);\n  uniformDeclaration += `outShape : ${outputDataType}, `;\n  stridesLength = outputData.shape.length - 1;\n  stridesDataType = getCoordsDataType(stridesLength);\n  uniformDeclaration += `\n         outShapeStrides: ${stridesDataType}, `;\n\n  if (program.size) {\n    uniformDeclaration += 'size : i32, ';\n  }\n\n  if (program.uniforms) {\n    uniformDeclaration += program.uniforms;\n  }\n  uniformDeclaration += '};';\n  uniformDeclaration = insertAlignment(uniformDeclaration);\n\n  prefixSnippets.push(uniformDeclaration);\n\n  // Output buffer.\n  if (program.atomic) {\n    prefixSnippets.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    `);\n  } else {\n    prefixSnippets.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${\n        dataTypeToGPUType(outputData.dtype, program.outputComponent)}>;\n    `);\n  }\n  program.variableNames.forEach((x, i) => {\n    prefixSnippets.push(`\n      @group(0) @binding(${1 + i}) var<storage, read> ${x}: array<${\n        program.variableComponents ?\n            dataTypeToGPUType(\n                inputInfo[i].dtype, program.variableComponents[i]) :\n            dataTypeToGPUType(inputInfo[i].dtype, program.outputComponent)}>;\n        `);\n  });\n\n  if (uniformDeclaration !== '') {\n    prefixSnippets.push(`\n      @group(0) @binding(${\n        1 + program.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);\n  }\n\n  const coordsSnippet =\n      getOutputCoordsSnippet(outputData.shape, program.dispatchLayout);\n\n  const sources = [\n    commonSnippet, prefixSnippets.join('\\n') + isInfSnippet,\n    getCoordsFromIndexSnippet(outputData.shape), coordsSnippet,\n    getOutputIndexFromCoordsSnippet(outputData.shape.length)\n  ];\n  if (!program.atomic) {\n    sources.push(setOutputSnippet(\n        outputData.shape, outputData.dtype, program.outputComponent));\n  }\n\n  program.variableNames.forEach((x, i) => {\n    sources.push(`${getCoordsFromIndexSnippet(inputInfo[i].shape, x)}`);\n  });\n\n  const inputSnippet =\n      inputInfo\n          .map(\n              (x, i) => getInputSnippet(\n                  x, outputData.shape,\n                  program.variableComponents ? program.variableComponents[i] :\n                                               program.outputComponent,\n                  program.dispatchLayout.x.length === outputData.shape.length))\n          .join('\\n');\n  sources.push(inputSnippet);\n  sources.push(program.getUserCode());\n  const useGlobalIndex = isFlatDispatchLayout(program);\n  sources.push(getStartHeaderString(useGlobalIndex, program));\n  const source = sources.join('\\n');\n  return source;\n}\n\nexport function makeShaderKey<R extends Rank>(\n    program: WebGPUProgram, inputsData: InputInfo[],\n    output: TensorInfo): string {\n  let key = program.shaderKey;\n  if (program.pixelsOpType != null) {\n    return key;\n  }\n\n  const shapes: number[][] = [];\n  const types: Array<keyof DataTypeMap> = [];\n  inputsData.forEach(element => {\n    shapes.push(element.shape);\n    types.push(element.dtype);\n  });\n  shapes.push(output.shape);\n  types.push(output.dtype);\n\n  const broadcastDims =\n      inputsData.map(d => backend_util.getBroadcastDims(d.shape, output.shape));\n  const inputShapesEqualsOutShape =\n      inputsData.map(d => util.arraysEqual(d.shape, output.shape)).join('_');\n  const broadcastDimsKey = broadcastDims.map(d => d.join('_')).join(';');\n\n  const flatDispatchString = isFlatDispatch(program) ? 'flatDispatch' : '';\n\n  key += '_' + (program.workgroupSize ? program.workgroupSize.join(',') : '') +\n      shapes.map(shape => shape.length).join(',') + types.join(',') +\n      program.variableNames.join(',') + broadcastDimsKey +\n      inputShapesEqualsOutShape + flatDispatchString;\n\n  return key;\n}\n\nconst commonSnippet = `\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n`;\n\nconst isInfSnippet = `\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n`;\n\ntype InputInfo = {\n  dtype: DataType; shape: number[]; name: string;\n};\n\n/**\n * Derives logical coordinates from a flat index. Performs integer division\n * with each stride and decrements the index until the index equals the final\n * dimension coordinate.\n */\nexport function getCoordsFromIndexSnippet(shape: number[], name = ''): string {\n  const rank = shape.length;\n  const funcName = name !== '' ?\n      `get${name.charAt(0).toUpperCase() + name.slice(1)}CoordsFromIndex` :\n      'getCoordsFromIndex';\n  const stridesName = name !== '' ?\n      `${name.charAt(0).toLowerCase() + name.slice(1)}ShapeStrides` :\n      `outShapeStrides`;\n\n  if (rank <= 1) {\n    return `fn ${funcName}(index : i32) -> i32 { return index; }`;\n  }\n\n  const strides = util.computeStrides(shape);\n  const dtype = getCoordsDataType(rank);\n\n  const coords: string[] = [];\n  for (let i = 0; i < rank; i++) {\n    coords.push(`d${i}`);\n  }\n\n  if (strides.length === 1) {\n    return `    fn ${funcName}(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.${\n        stridesName}; let d1 = index - d0 * uniforms.${stridesName};\n      return vec2<i32>(d0, d1);\n    }`;\n  }\n  let snippet;\n  snippet = 'var index2 = index;' +\n      strides\n          .map((_, i) => {\n            const line1 = `let ${coords[i]} = index2 / uniforms.${\n                stridesName}.${getCoordsXYZ(i)}`;\n            const line2 = i === strides.length - 1 ?\n                `let ${coords[i + 1]} = index2 - ${coords[i]} * uniforms.${\n                    stridesName}.${getCoordsXYZ(i)}` :\n                `index2 = index2 - ${coords[i]} * uniforms.${stridesName}.${\n                    getCoordsXYZ(i)}`;\n            return `${line1}; ${line2};`;\n          })\n          .join('');\n\n  return `\n    fn ${funcName}(index : i32) -> ${dtype} {\n      ${snippet}\n      return ${dtype}(${coords.join(',')});\n    }\n  `;\n}\n\nfunction getInputAtCoordsSnippet(\n    inputInfo: InputInfo, component: number): string {\n  const texName = inputInfo.name;\n  const rank = inputInfo.shape.length;\n  const type = getCoordsDataType(rank);\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, rank);\n  const inputs = dims.map(d => `${d} : i32`).join(', ');\n\n  if (rank < 1) {\n    return `\n      fn ${funcName}() -> ${typeSnippet(component)} {\n        return ${typeSnippet(component)}(${texName}[0]);\n      }\n    `;\n  }\n\n  const shapeStr =\n      `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;\n  let rankStr = `${rank}D`;\n  if (rank === 0) {\n    rankStr = '1D';\n  }\n\n  return `\n    fn ${funcName}(${inputs}) -> ${typeSnippet(component)} {\n      return ${typeSnippet(component)}(${texName}[getIndexFromCoords${\n      rankStr}(${type}(${dims.join(',')}),\n        ${shapeStr})${component === 1 ? '' : ` / ${component}`}]);\n    }\n   `;\n}\n\nfunction getInputByOutputSnippet(\n    inputInfo: InputInfo, outShape: number[], component: number,\n    isFlatDispatchLayout: boolean): string {\n  const texName = inputInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  const funcName = 'get' + texFuncSnippet + 'ByOutput';\n\n  const inRank = inputInfo.shape.length;\n  const outRank = outShape.length;\n  const type = getCoordsDataType(outRank);\n\n  // If the inShape equals the outShape and the dispatch layout is flat, we can\n  // directly use |gl_GlobalInvocationID.x| as the index and don't need coords\n  // conversion between these two shapes.\n  if (util.arraysEqual(inputInfo.shape, outShape) && isFlatDispatchLayout) {\n    return `\n    fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)} {\n      return ${typeSnippet(component)}(${texName}[globalIndex]);\n    }\n\n    fn ${funcName}Coords(coords : ${type}) -> ${typeSnippet(component)} {\n      return ${typeSnippet(component)}(${texName}[${\n        outRank > 1 ? 'getOutputIndexFromCoords(coords)' :\n                      'coords'}${component === 1 ? '' : ` / ${component}`}]);\n    }\n    `;\n  }\n\n  const broadcastDims =\n      backend_util.getBroadcastDims(inputInfo.shape, outShape);\n  const rankDiff = outRank - inRank;\n\n  let coordsSnippet = '';\n\n  if (inRank === 0) {\n    return `\n    fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)}{\n      return get${texFuncSnippet}();\n    }\n\n    fn ${funcName}Coords(coords : ${type}) -> ${typeSnippet(component)}{\n      return get${texFuncSnippet}();\n    }\n  `;\n  } else {\n    if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet =\n          broadcastDims.map(d => `coords.${getCoordsXYZ(d + rankDiff)} = 0;`)\n              .join('\\n');\n    }\n  }\n\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    if (outRank > 1) {\n      const coordsType = getCoordsDataType(inRank);\n      const coordsValues =\n          inputInfo.shape.map((s, i) => `coords.${getCoordsXYZ(i + rankDiff)}`)\n              .join(', ');\n      unpackedCoordsSnippet = `${coordsType}(${coordsValues})`;\n    } else {\n      unpackedCoordsSnippet = 'coords';\n    }\n  }\n\n  const shapeStr =\n      `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;\n  const rankStr = `${inRank}D`;\n\n  return `\n  fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)} {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${coordsSnippet}\n    return ${typeSnippet(component)}(${texName}[getIndexFromCoords${rankStr}(${\n      unpackedCoordsSnippet}, ${shapeStr})${\n      component === 1 ? '' : ` / ${component}`}]);\n  }\n\n  fn ${funcName}Coords(coordsIn : ${type}) -> ${typeSnippet(component)} {\n    var coords = coordsIn;\n    ${coordsSnippet}\n    return ${typeSnippet(component)}(${texName}[getIndexFromCoords${rankStr}(${\n      unpackedCoordsSnippet}, ${shapeStr})${\n      component === 1 ? '' : ` / ${component}`}]);\n  }\n`;\n}\n\nfunction getInputSnippet(\n    inputInfo: InputInfo, outShape: number[], component: number,\n    isFlatDispatchLayout: boolean): string {\n  let res = getInputAtCoordsSnippet(inputInfo, component);\n\n  const inShape = inputInfo.shape;\n  if (inShape.length <= outShape.length) {\n    res += getInputByOutputSnippet(\n        inputInfo, outShape, component, isFlatDispatchLayout);\n  }\n\n  return res;\n}\n\n/**\n * Generates getOutputCoords() function that computes output coordinates\n * from dispatch geometry to reduce arithmetic.\n */\nfunction getOutputCoordsSnippet(\n    outShape: number[],\n    dispatchLayout: {x: number[], y?: number[], z?: number[]}): string {\n  const {x, y = [], z = []} = dispatchLayout;\n\n  const outRank = outShape.length;\n  const rank = x.length + y.length + z.length;\n  // getOutputCoords is only meaningful when the output rank is same with\n  // dispatch layout rank.\n  if (rank !== outRank) {\n    return '';\n  }\n\n  if (x.length === outRank) {\n    const dtype = getCoordsDataType(outRank);\n    const snippet = `fn getOutputCoords() -> ${dtype}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `;\n    return snippet;\n  }\n\n  let gatherDimensionsStr = '';\n  const dims = [x, y, z];\n\n  for (let i = 0; i < dims.length; i++) {\n    const arr = dims[i];\n\n    if (arr.length === 0) {\n      continue;\n    }\n\n    if (arr.length === 1) {\n      gatherDimensionsStr += `let d${arr[0]} = i32(globalId[${i}]);`;\n    } else {\n      const strides = symbolicallyComputeStrides(arr, 'uniforms.outShape');\n      gatherDimensionsStr += `var index${i} = i32(globalId[${i}]);`;\n      for (let j = 0; j < strides.length; j++) {\n        gatherDimensionsStr += `let d${arr[j]} = index${i} / ${strides[j]};`;\n\n        if (j === strides.length - 1) {\n          gatherDimensionsStr += `let d${arr[j + 1]} = ` +\n              `index${i} - d${arr[j]} * ${strides[j]};`;\n        } else {\n          gatherDimensionsStr +=\n              `index${i} = index${i} - d${arr[j]} * ${strides[j]};`;\n        }\n      }\n    }\n  }\n\n  const dimensions = [];\n  for (let i = 0; i < rank; i++) {\n    dimensions.push(`d${i}`);\n  }\n\n  const dtype = getCoordsDataType(rank);\n  let snippet = `fn getOutputCoords() -> ${dtype} {\n  ${gatherDimensionsStr}\n`;\n  if (dimensions.length === 0) {\n    snippet += `return ${dtype}(0); }`;\n  } else {\n    snippet += `return ${dtype}(${dimensions.join(',')}); }`;\n  }\n\n  return snippet;\n}\n\nfunction getOutputIndexFromCoordsSnippet(outRank: number) {\n  let snippet = '';\n  switch (outRank) {\n    case 0:\n    case 1:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        `;\n      break;\n    case 2:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        `;\n      break;\n    case 3:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        `;\n      break;\n    case 4:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        `;\n      break;\n    case 5:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        `;\n      break;\n    case 6:\n      snippet += `\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        `;\n      break;\n    default:\n      util.assert(false, () => `Unsupported ${outRank}D shape`);\n      break;\n  }\n  return snippet;\n}\n\nfunction isFlatDispatch(program: WebGPUProgram): boolean {\n  return program.dispatch[1] === 1 && program.dispatch[2] === 1;\n}\n\nexport function dataTypeToGPUType(type: DataType, component = 1) {\n  if (type === 'float32') {\n    return typeSnippet(component, 'f32');\n  } else if (type === 'int32' || type === 'bool') {\n    return typeSnippet(component, 'i32');\n  }\n  throw new Error(`type ${type} is not supported.`);\n}\n\nfunction setOutputSnippet(\n    outShape: number[], outBufferType: DataType, component: number): string {\n  const outRank = outShape.length;\n  const gpuType = dataTypeToGPUType(outBufferType, component);\n  let snippet =\n      `fn setOutputAtIndex(flatIndex : i32, value : ${typeSnippet(component)}) {\n      result[flatIndex] = ${gpuType}(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ${\n          typeSnippet(component, 'i32')}) {\n      result[flatIndex] = ${gpuType}(value);\n    }\n    `;\n  if (outRank >= 2) {\n    const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, outRank);\n    const type = getCoordsDataType(outRank);\n\n    snippet += `\n      fn setOutputAtCoords(${dims.map(d => `${d} : i32`).join(', ')}, value : ${\n        typeSnippet(component)}) {\n        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));\n        setOutputAtIndex(flatIndex${\n        component === 1 ? '' : ` / ${component}`}, value);\n      }\n      fn setOutputAtCoordsI32(${\n        dims.map(d => `${d} : i32`).join(', ')}, value : ${\n        typeSnippet(component, 'i32')}) {\n        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));\n        setOutputAtIndexI32(flatIndex${\n        component === 1 ? '' : ` / ${component}`}, value);\n      }\n    `;\n  }\n\n  return snippet;\n}\n\nfunction insertAlignment(uniformShader: string) {\n  // insert alignment when current pattern is vec5 or vec6\n  const curInsertRe = /(\\w+)\\s*:\\s*vec(5|6)/g;\n  uniformShader = uniformShader.replace(curInsertRe, (match) => {\n    return '@align(16) ' + match;\n  });\n\n  // insert alignment when previous pattern is vec5 or vec6\n  const preInsertRe = /vec(5|6)\\s*,\\s*(\\w+)/g;\n  uniformShader = uniformShader.replace(preInsertRe, (_, p1, p2) => {\n    return `vec${p1}, @align(16) ${p2}`;\n  });\n  return uniformShader;\n}\nfunction isFlatDispatchLayout(program: WebGPUProgram): boolean {\n  if (program.dispatchLayout.hasOwnProperty('y') &&\n      program.dispatchLayout.y.length !== 0) {\n    return false;\n  }\n  if (program.dispatchLayout.hasOwnProperty('z') &&\n      program.dispatchLayout.z.length !== 0) {\n    return false;\n  }\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}