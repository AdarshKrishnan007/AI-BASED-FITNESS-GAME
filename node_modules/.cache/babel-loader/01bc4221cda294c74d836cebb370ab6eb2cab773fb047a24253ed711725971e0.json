{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { activationFnSnippet, biasActivationSnippet } from './activation_util';\nimport { getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch } from './webgpu_util';\nexport class Conv2DNaiveProgram {\n  constructor(convInfo) {\n    let addBias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let activation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let hasPreluActivationWeights = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    this.variableNames = ['x', 'W'];\n    this.uniforms = 'filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,';\n    this.workgroupSize = [4, 4, 8];\n    this.outputShape = convInfo.outShape;\n    this.isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    this.dispatchLayout = this.isChannelsLast ? {\n      x: [2],\n      y: [1],\n      z: [0, 3]\n    } : {\n      x: [3],\n      y: [2],\n      z: [0, 1]\n    };\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    this.shaderKey = \"conv2dnaive_\".concat(this.activation, \"_\").concat(this.isChannelsLast);\n  }\n  getUserCode() {\n    const userCode = \"\\n       \".concat(activationFnSnippet(this.activation, this.hasPreluActivationWeights, false, 4), \"\\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\\n         let coords = vec4<i32>(batch, row, col, chan);\\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\\n           return  getX(batch, row, col, chan);\\n         } else {\\n          return 0.0;\\n         }\\n       }\\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\\n           return getW(row, col, xChannel, outChannel);\\n          } else {\\n            return 0.0;\\n          }\\n       }\\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\\n         let coords = \").concat(this.isChannelsLast ? \"vec4<i32>(batch, row, col, chan);\" : \"vec4<i32>(batch, chan, row, col);\", \"\\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\\n           var value = valueIn;\\n           \").concat(biasActivationSnippet(this.addBias, this.activation), \"\\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\\n         }\\n       }\\n       \").concat(main('index'), \" {\\n         let coords = getOutputCoords();\\n         let batch = coords[0];\\n         let outChannel = \").concat(this.isChannelsLast ? \"coords[3];\" : \"coords[1];\", \"\\n         let outRow = \").concat(this.isChannelsLast ? \"coords[1];\" : \"coords[2];\", \"\\n         let outCol = \").concat(this.isChannelsLast ? \"coords[2];\" : \"coords[3];\", \"\\n         var acc : f32 = 0.0;\\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\\n             for (var xChannel = 0; xChannel < \").concat(this.isChannelsLast ? \"uniforms.xShape[3];\" : \"uniforms.xShape[1];\", \" xChannel = xChannel + 1) {\\n               \").concat(this.isChannelsLast ? \"let v = readInp(batch, xRow, xCol, xChannel);\" : \"let v = readInp(batch, xChannel, xRow, xCol);\", \"\\n               let f = readFilt(row, col, xChannel, outChannel);\\n               acc = acc + v * f;\\n             }\\n           }\\n         }\\n         writeResult(batch, outRow, outCol, outChannel, acc);\\n       }\\n     \");\n    return userCode;\n  }\n}","map":{"version":3,"names":["activationFnSnippet","biasActivationSnippet","getMainHeaderString","main","computeDispatch","Conv2DNaiveProgram","constructor","convInfo","addBias","arguments","length","undefined","activation","hasPreluActivationWeights","variableNames","uniforms","workgroupSize","outputShape","outShape","isChannelsLast","dataFormat","dispatchLayout","x","y","z","dispatch","push","shaderKey","concat","getUserCode","userCode"],"sources":["D:\\Fitness WebApp\\tfjs-backend-webgpu\\src\\conv2d_naive_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {activationFnSnippet, biasActivationSnippet} from './activation_util';\nimport {getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch} from './webgpu_util';\n\nexport class Conv2DNaiveProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x', 'W'];\n  uniforms =\n      'filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,';\n  workgroupSize: [number, number, number] = [4, 4, 8];\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivationWeights: boolean;\n  isChannelsLast: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: backend_util.Activation = null,\n      hasPreluActivationWeights = false) {\n    this.outputShape = convInfo.outShape;\n    this.isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    this.dispatchLayout = this.isChannelsLast ? {x: [2], y: [1], z: [0, 3]} :\n                                                {x: [3], y: [2], z: [0, 1]};\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.shaderKey = `conv2dnaive_${this.activation}_${this.isChannelsLast}`;\n  }\n\n  getUserCode(): string {\n    const userCode = `\n       ${\n        activationFnSnippet(\n            this.activation, this.hasPreluActivationWeights, false, 4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${\n        this.isChannelsLast ? `vec4<i32>(batch, row, col, chan);` :\n                              `vec4<i32>(batch, chan, row, col);`}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${biasActivationSnippet(this.addBias, this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${main('index')} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast ? `coords[3];` : `coords[1];`}\n         let outRow = ${this.isChannelsLast ? `coords[1];` : `coords[2];`}\n         let outCol = ${this.isChannelsLast ? `coords[2];` : `coords[3];`}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\n             for (var xChannel = 0; xChannel < ${\n        this.isChannelsLast ? `uniforms.xShape[3];` :\n                              `uniforms.xShape[1];`} xChannel = xChannel + 1) {\n               ${\n        this.isChannelsLast ? `let v = readInp(batch, xRow, xCol, xChannel);` :\n                              `let v = readInp(batch, xChannel, xRow, xCol);`}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `;\n    return userCode;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAmBA,SAAQA,mBAAmB,EAAEC,qBAAqB,QAAO,mBAAmB;AAC5E,SAAQC,mBAAmB,IAAIC,IAAI,QAAsB,kBAAkB;AAC3E,SAAQC,eAAe,QAAO,eAAe;AAE7C,OAAM,MAAOC,kBAAkB;EAc7BC,YACIC,QAAiC,EAEA;IAAA,IAFEC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;IAAA,IAClDG,UAAA,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAsC,IAAI;IAAA,IAC1CI,yBAAyB,GAAAJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;IAZrC,KAAAK,aAAa,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;IAC1B,KAAAC,QAAQ,GACJ,mFAAmF;IACvF,KAAAC,aAAa,GAA6B,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAUjD,IAAI,CAACC,WAAW,GAAGV,QAAQ,CAACW,QAAQ;IACpC,IAAI,CAACC,cAAc,GAAGZ,QAAQ,CAACa,UAAU,KAAK,cAAc;IAC5D,IAAI,CAACC,cAAc,GAAG,IAAI,CAACF,cAAc,GAAG;MAACG,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;IAAC,CAAC,GAC3B;MAACF,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;IAAC,CAAC;IACvE,IAAI,CAACC,QAAQ,GAAGrB,eAAe,CAC3B,IAAI,CAACiB,cAAc,EAAE,IAAI,CAACJ,WAAW,EAAE,IAAI,CAACD,aAAa,CAAC;IAC9D,IAAI,CAACR,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACI,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,yBAAyB,GAAGA,yBAAyB;IAE1D,IAAIL,OAAO,EAAE;MACX,IAAI,CAACM,aAAa,CAACY,IAAI,CAAC,MAAM,CAAC;;IAGjC,IAAIb,yBAAyB,EAAE;MAC7B,IAAI,CAACC,aAAa,CAACY,IAAI,CAAC,wBAAwB,CAAC;;IAGnD,IAAI,CAACC,SAAS,kBAAAC,MAAA,CAAkB,IAAI,CAAChB,UAAU,OAAAgB,MAAA,CAAI,IAAI,CAACT,cAAc,CAAE;EAC1E;EAEAU,WAAWA,CAAA;IACT,MAAMC,QAAQ,eAAAF,MAAA,CAEV5B,mBAAmB,CACf,IAAI,CAACY,UAAU,EAAE,IAAI,CAACC,yBAAyB,EAAE,KAAK,EAAE,CAAC,CAAC,ivBAAAe,MAAA,CAmB9D,IAAI,CAACT,cAAc,4EACsC,iHAAAS,MAAA,CAGpD3B,qBAAqB,CAAC,IAAI,CAACO,OAAO,EAAE,IAAI,CAACI,UAAU,CAAC,mHAAAgB,MAAA,CAIxDzB,IAAI,CAAC,OAAO,CAAC,+GAAAyB,MAAA,CAGM,IAAI,CAACT,cAAc,8BAA8B,8BAAAS,MAAA,CACrD,IAAI,CAACT,cAAc,8BAA8B,8BAAAS,MAAA,CACjD,IAAI,CAACT,cAAc,8BAA8B,8bAAAS,MAAA,CAOjE,IAAI,CAACT,cAAc,gDACwB,kDAAAS,MAAA,CAE3C,IAAI,CAACT,cAAc,oGACkD,oOAQvE;IACF,OAAOW,QAAQ;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}