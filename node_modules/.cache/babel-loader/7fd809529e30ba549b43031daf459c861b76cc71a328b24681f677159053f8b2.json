{"ast":null,"code":"import * as tf from \"@tensorflow/tfjs\";\nimport * as posedetection from \"@tensorflow-models/pose-detection\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nlet detector;\n\n// let audio = {\n//   good: new Audio(\"/audio/good.mp3\"),\n//   bad: new Audio(\"/audio/bad.mp3\"),\n// };\n\nexport async function loadModel() {\n  await tf.setBackend(\"webgl\");\n  await tf.ready();\n  detector = await posedetection.createDetector(posedetection.SupportedModels.MoveNet, {\n    modelType: posedetection.movenet.modelType.SINGLEPOSE_LIGHTNING\n  });\n}\nlet lastSpokenTime = 0;\nlet cooldown = 1000; // 1 second cooldown to prevent overlap\n\nfunction speakFeedback(msg) {\n  const now = Date.now();\n\n  // Prevent overlapping or repeating too fast\n  if (now - lastSpokenTime < cooldown) return;\n  lastSpokenTime = now;\n\n  // Cancel any ongoing speech\n  window.speechSynthesis.cancel();\n  const speech = new SpeechSynthesisUtterance(msg);\n  speech.volume = 1;\n  speech.pitch = 1;\n  speech.rate = 1;\n  window.speechSynthesis.speak(speech);\n}\n\n// Helper to get x/y of a keypoint\nfunction getXY(keypoints, name) {\n  const kp = keypoints.find(k => k.name === name);\n  return {\n    x: (kp === null || kp === void 0 ? void 0 : kp.x) || 0,\n    y: (kp === null || kp === void 0 ? void 0 : kp.y) || 0,\n    score: (kp === null || kp === void 0 ? void 0 : kp.score) || 0\n  };\n}\nfunction getAngle(A, B, C) {\n  // Vectors: BA and BC\n  const BAx = A.x - B.x;\n  const BAy = A.y - B.y;\n  const BCx = C.x - B.x;\n  const BCy = C.y - B.y;\n  const dotProduct = BAx * BCx + BAy * BCy;\n  const magBA = Math.sqrt(BAx ** 2 + BAy ** 2);\n  const magBC = Math.sqrt(BCx ** 2 + BCy ** 2);\n  if (magBA === 0 || magBC === 0) return 0;\n  const angleRad = Math.acos(dotProduct / (magBA * magBC));\n  return angleRad * (180 / Math.PI); // Convert to degrees\n}\n\n// Basic keypoint reliability check\nfunction isReliable(kp, threshold = 0.5) {\n  return kp.score >= threshold;\n}\n\n// Exercise handlers\nconst exerciseHandlers = {\n  squat: (k, state) => {\n    const lHip = getXY(k, \"left_hip\");\n    const lKnee = getXY(k, \"left_knee\");\n    const lAnkle = getXY(k, \"left_ankle\");\n    const rHip = getXY(k, \"right_hip\");\n    const rKnee = getXY(k, \"right_knee\");\n    const rAnkle = getXY(k, \"right_ankle\");\n\n    // Ensure data is reliable\n    if (!isReliable(lHip) || !isReliable(lKnee) || !isReliable(lAnkle) || !isReliable(rHip) || !isReliable(rKnee) || !isReliable(rAnkle)) return {};\n\n    // Helper: Calculate knee angle\n    const getAngle = (a, b, c) => {\n      const ab = {\n        x: a.x - b.x,\n        y: a.y - b.y\n      };\n      const cb = {\n        x: c.x - b.x,\n        y: c.y - b.y\n      };\n      const dot = ab.x * cb.x + ab.y * cb.y;\n      const magAB = Math.hypot(ab.x, ab.y);\n      const magCB = Math.hypot(cb.x, cb.y);\n      const angle = Math.acos(dot / (magAB * magCB));\n      return angle * 180 / Math.PI;\n    };\n    const leftKneeAngle = getAngle(lHip, lKnee, lAnkle);\n    const rightKneeAngle = getAngle(rHip, rKnee, rAnkle);\n    const avgKneeAngle = (leftKneeAngle + rightKneeAngle) / 2;\n    const isDown = avgKneeAngle < 100; // <100° indicates squat bottom\n    const isUp = avgKneeAngle > 160; // >160° indicates standing\n\n    // DOWN phase\n    if (!state.down) {\n      if (isDown) {\n        state.downCount = (state.downCount || 0) + 1;\n        if (state.downCount > 4) {\n          state.down = true;\n          state.downCount = 0;\n          speakFeedback(\"Good depth!\");\n          return {\n            feedback: \"Squat depth reached!\",\n            repCounted: false\n          };\n        }\n      } else {\n        state.downCount = 0;\n        return {\n          feedback: \"Go deeper!\",\n          scorePenalty: 1\n        };\n      }\n    }\n\n    // UP phase\n    else {\n      if (isUp) {\n        state.upCount = (state.upCount || 0) + 1;\n        if (state.upCount > 4) {\n          state.down = false;\n          state.upCount = 0;\n          speakFeedback(\"Squat counted!\");\n          return {\n            feedback: \"Squat counted!\",\n            repCounted: true\n          };\n        }\n      } else {\n        state.upCount = 0;\n      }\n    }\n    return {};\n  },\n  jump: (k, state) => {\n    const hip = getXY(k, \"left_hip\");\n    if (!isReliable(hip)) return {};\n    if (state.prevHipY == null) state.prevHipY = hip.y;\n    const jumpHeight = state.prevHipY - hip.y;\n    const jumpUp = jumpHeight > 20;\n    const weakJump = jumpHeight > 5 && jumpHeight <= 20; // Low effort jump\n    const land = hip.y - state.prevHipY > 10;\n\n    // Weak jump form penalty\n    if (!state.jumping && weakJump) {\n      speakFeedback(\"Jump higher!\");\n      return {\n        feedback: \"Jump higher!\",\n        scorePenalty: 1,\n        repCounted: false\n      };\n    }\n\n    // Good jump detected\n    if (!state.jumping && jumpUp) {\n      state.jumping = true;\n      speakFeedback(\"Nice jump!\");\n      return {\n        feedback: \"Nice jump!\"\n      };\n    }\n\n    // Landing after jump\n    if (state.jumping && land) {\n      state.jumping = false;\n      speakFeedback(\"Jump counted!\");\n      return {\n        feedback: \"Jump counted!\",\n        repCounted: true\n      };\n    }\n    state.prevHipY = hip.y;\n    return {};\n  },\n  pushup: (k, state) => {\n    const shoulder = getXY(k, \"left_shoulder\");\n    const elbow = getXY(k, \"left_elbow\");\n    const wrist = getXY(k, \"left_wrist\");\n    const hip = getXY(k, \"left_hip\");\n    if (!isReliable(shoulder) || !isReliable(elbow) || !isReliable(wrist) || !isReliable(hip)) return {};\n\n    // Helper: calculate angle between 3 points\n    const getAngle = (a, b, c) => {\n      const ab = {\n        x: a.x - b.x,\n        y: a.y - b.y\n      };\n      const cb = {\n        x: c.x - b.x,\n        y: c.y - b.y\n      };\n      const dot = ab.x * cb.x + ab.y * cb.y;\n      const magAB = Math.hypot(ab.x, ab.y);\n      const magCB = Math.hypot(cb.x, cb.y);\n      const angle = Math.acos(dot / (magAB * magCB));\n      return angle * 180 / Math.PI;\n    };\n    const elbowAngle = getAngle(shoulder, elbow, wrist);\n    const bodyAngle = getAngle(shoulder, hip, {\n      x: hip.x,\n      y: hip.y + 0.1\n    }); // vertical approx\n\n    // Thresholds for down/up phase:\n    const downThreshold = 90; // elbow angle less than 90° means pushup down phase\n    const upThreshold = 160; // elbow angle more than 160° means pushup up phase\n\n    state.downCount = state.downCount || 0;\n    state.upCount = state.upCount || 0;\n\n    // Detect pushup DOWN phase\n    if (!state.down) {\n      if (elbowAngle < downThreshold) {\n        state.downCount++;\n        if (state.downCount > 2) {\n          state.down = true;\n          state.downCount = 0;\n          speakFeedback(\"Good pushup depth!\");\n          return {\n            feedback: \"Good pushup depth!\",\n            repCounted: false\n          };\n        }\n      } else {\n        state.downCount = 0;\n        return {\n          feedback: \"Lower your chest!\",\n          scorePenalty: 1\n        };\n      }\n    }\n    // Detect pushup UP phase\n    else {\n      if (elbowAngle > upThreshold) {\n        state.upCount++;\n        if (state.upCount > 4) {\n          state.down = false;\n          state.upCount = 0;\n          speakFeedback(\"Pushup counted!\");\n          return {\n            feedback: \"Pushup counted!\",\n            repCounted: true\n          };\n        }\n      } else {\n        state.upCount = 0;\n      }\n    }\n    return {};\n  },\n  plank: (k, state, deltaTime) => {\n    const head = getXY(k, \"head\") || getXY(k, \"nose\");\n    const shoulder = getXY(k, \"left_shoulder\");\n    const hip = getXY(k, \"left_hip\");\n    if (!isReliable(head) || !isReliable(shoulder) || !isReliable(hip)) {\n      state.plankHoldTime = 0; // reset if bad frame\n      state.lastSecondReported = 0; // reset feedback tracking\n      return {};\n    }\n    const hipDrop = hip.y - shoulder.y;\n    const headLift = head.y - shoulder.y;\n    if (hipDrop > 50) {\n      speakFeedback(\"Lift your hips a bit!\");\n      state.plankHoldTime = 0;\n      state.lastSecondReported = 0;\n      return {\n        feedback: \"Lift your hips a bit!\",\n        scorePenalty: 1\n      };\n    }\n    if (headLift < -40) {\n      speakFeedback(\"Lower your head slightly!\");\n      state.plankHoldTime = 0;\n      state.lastSecondReported = 0;\n      return {\n        feedback: \"Lower your head slightly!\",\n        scorePenalty: 1\n      };\n    }\n\n    // Accumulate plank hold time\n    state.plankHoldTime = (state.plankHoldTime || 0) + deltaTime;\n\n    // Calculate current whole seconds held\n    const secondsHeld = Math.floor(state.plankHoldTime / 1000);\n\n    // Provide feedback only when a new whole second is reached\n    if (secondsHeld > (state.lastSecondReported || 0)) {\n      state.lastSecondReported = secondsHeld;\n      speakFeedback(`Plank held: ${secondsHeld} seconds`);\n    }\n    if (state.plankHoldTime >= 10000) {\n      // 10 seconds\n      speakFeedback(\"Plank hold complete!\");\n      state.plankHoldTime = 0; // reset for next rep\n      state.lastSecondReported = 0;\n      return {\n        feedback: \"Plank complete!\",\n        repCounted: true\n      };\n    }\n    return {\n      feedback: `Good plank hold! ${secondsHeld}s`,\n      repCounted: false\n    };\n  }\n};\nlet lastStandInViewTime = 0;\nexport async function startPoseDetection(videoElement, exercise, targetReps, feedbackCallback = null, userInfo) {\n  if (!detector) await loadModel();\n  if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {\n    await new Promise(resolve => {\n      const checkReady = () => {\n        if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {\n          resolve();\n        } else {\n          requestAnimationFrame(checkReady); // Keep checking\n        }\n      };\n      videoElement.onloadedmetadata = checkReady;\n      checkReady();\n    });\n  }\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = videoElement.videoWidth;\n  canvas.height = videoElement.videoHeight;\n  document.body.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n  let totalScore = 500;\n  let badFormCount = 0;\n  let repCount = 0;\n  const state = {};\n  const MET_VALUES = {\n    pushup: 8,\n    squat: 7,\n    plank: 5,\n    jumping_jack: 8\n    // add more as needed\n  };\n  let workoutComplete = false; // ✅ Add flag to stop detection\n\n  const workoutStartTime = Date.now();\n  return new Promise(resolve => {\n    const timeout = setTimeout(() => {\n      document.body.removeChild(canvas);\n      return resolve(null);\n    }, 300000);\n    const detect = async () => {\n      var _poses$;\n      if (workoutComplete) return; // ✅ Stop further frames\n\n      const poses = await detector.estimatePoses(videoElement);\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.font = \"20px Arial\";\n      if (!poses || !Array.isArray(poses) || poses.length === 0 || !((_poses$ = poses[0]) !== null && _poses$ !== void 0 && _poses$.keypoints) || poses[0].keypoints.length === 0) {\n        ctx.fillStyle = \"red\";\n        const now = Date.now();\n        if (now - lastStandInViewTime > 4000) {\n          lastStandInViewTime = now;\n        }\n        requestAnimationFrame(detect);\n        return;\n      }\n      const pose = poses[0];\n      const handler = exerciseHandlers[exercise];\n      if (!handler) throw new Error(\"Unsupported exercise: \" + exercise);\n      const result = handler(pose.keypoints, state);\n      if (result.feedback) {\n        ctx.fillStyle = result.scorePenalty ? \"red\" : \"green\";\n        ctx.fillText(result.feedback, 10, 30);\n        speakFeedback(result.feedback);\n      }\n      if (result.scorePenalty) {\n        totalScore -= result.scorePenalty;\n      }\n      if (result.repCounted) {\n        repCount++;\n        speakFeedback(`Rep ${repCount} completed!`);\n        if (result.scorePenalty) {\n          badFormCount++; // Count bad form once per rep\n        }\n      }\n      if (typeof feedbackCallback === \"function\") {\n        feedbackCallback({\n          reps: repCount,\n          formFeedback: result.feedback\n        });\n      }\n      if (repCount >= targetReps) {\n        var _userInfo$gender;\n        workoutComplete = true; // ✅ Set flag to stop further detection\n        clearTimeout(timeout);\n        document.body.removeChild(canvas);\n        window.speechSynthesis.cancel();\n        const workoutEndTime = Date.now();\n        const durationMinutes = (workoutEndTime - workoutStartTime) / 60000;\n        let rawAccuracy = (targetReps - badFormCount) / targetReps * 100;\n        let adjustedAccuracy = Math.max(30, Math.min(rawAccuracy, 95)); // clamp between 30 and 95\n\n        let level = \"\";\n        if (adjustedAccuracy < 40) level = \"Weak\";else if (adjustedAccuracy < 60) level = \"Beginner\";else if (adjustedAccuracy < 80) level = \"Intermediate\";else level = \"Advanced\";\n        const formQuality = badFormCount / targetReps;\n        console.log(\"Target Reps:\", targetReps);\n        console.log(\"Bad Form Count:\", badFormCount);\n        console.log(\"Form Quality:\", formQuality);\n        let feedback = \"Perfect form!\";\n        if (formQuality > 0.5) {\n          feedback = \"Work on your form!\";\n        } else if (formQuality > 0.25) {\n          feedback = \"Try better form next time!\";\n        } else if (formQuality > 0.1) {\n          feedback = \"Pretty good form!\";\n        }\n\n        // Calories calculation with gender factor\n        const genderFactor = (userInfo === null || userInfo === void 0 ? void 0 : (_userInfo$gender = userInfo.gender) === null || _userInfo$gender === void 0 ? void 0 : _userInfo$gender.toLowerCase()) === \"male\" ? 1 : 0.95;\n        const met = MET_VALUES[exercise.toLowerCase()] || 6;\n        const caloriesBurned = met * ((userInfo === null || userInfo === void 0 ? void 0 : userInfo.weight) || 70) * (durationMinutes / 60) * genderFactor;\n        return resolve({\n          score: Math.max(0, totalScore),\n          accuracy: Math.floor(adjustedAccuracy),\n          xp: Math.floor(Math.max(0, totalScore * 0.8)),\n          feedback: badFormCount > 0 ? \"Try better form next time!\" : \"Perfect form!\",\n          reps: repCount,\n          badFormCount,\n          calories: caloriesBurned.toFixed(2),\n          durationMinutes: durationMinutes.toFixed(2)\n        });\n      }\n      requestAnimationFrame(detect);\n    };\n    detect();\n  });\n}","map":{"version":3,"names":["tf","posedetection","detector","loadModel","setBackend","ready","createDetector","SupportedModels","MoveNet","modelType","movenet","SINGLEPOSE_LIGHTNING","lastSpokenTime","cooldown","speakFeedback","msg","now","Date","window","speechSynthesis","cancel","speech","SpeechSynthesisUtterance","volume","pitch","rate","speak","getXY","keypoints","name","kp","find","k","x","y","score","getAngle","A","B","C","BAx","BAy","BCx","BCy","dotProduct","magBA","Math","sqrt","magBC","angleRad","acos","PI","isReliable","threshold","exerciseHandlers","squat","state","lHip","lKnee","lAnkle","rHip","rKnee","rAnkle","a","b","c","ab","cb","dot","magAB","hypot","magCB","angle","leftKneeAngle","rightKneeAngle","avgKneeAngle","isDown","isUp","down","downCount","feedback","repCounted","scorePenalty","upCount","jump","hip","prevHipY","jumpHeight","jumpUp","weakJump","land","jumping","pushup","shoulder","elbow","wrist","elbowAngle","bodyAngle","downThreshold","upThreshold","plank","deltaTime","head","plankHoldTime","lastSecondReported","hipDrop","headLift","secondsHeld","floor","lastStandInViewTime","startPoseDetection","videoElement","exercise","targetReps","feedbackCallback","userInfo","videoWidth","videoHeight","Promise","resolve","checkReady","requestAnimationFrame","onloadedmetadata","canvas","document","createElement","width","height","body","appendChild","ctx","getContext","totalScore","badFormCount","repCount","MET_VALUES","jumping_jack","workoutComplete","workoutStartTime","timeout","setTimeout","removeChild","detect","_poses$","poses","estimatePoses","clearRect","font","Array","isArray","length","fillStyle","pose","handler","Error","result","fillText","reps","formFeedback","_userInfo$gender","clearTimeout","workoutEndTime","durationMinutes","rawAccuracy","adjustedAccuracy","max","min","level","formQuality","console","log","genderFactor","gender","toLowerCase","met","caloriesBurned","weight","accuracy","xp","calories","toFixed"],"sources":["D:/Fitness WebApp/client/src/utils/poseDetectionFrontend.js"],"sourcesContent":["import * as tf from \"@tensorflow/tfjs\";\r\nimport * as posedetection from \"@tensorflow-models/pose-detection\";\r\nimport \"@tensorflow/tfjs-backend-webgl\";\r\n\r\nlet detector;\r\n\r\n// let audio = {\r\n//   good: new Audio(\"/audio/good.mp3\"),\r\n//   bad: new Audio(\"/audio/bad.mp3\"),\r\n// };\r\n\r\nexport async function loadModel() {\r\n  await tf.setBackend(\"webgl\");\r\n  await tf.ready();\r\n  detector = await posedetection.createDetector(\r\n    posedetection.SupportedModels.MoveNet,\r\n    {\r\n      modelType: posedetection.movenet.modelType.SINGLEPOSE_LIGHTNING,\r\n    }\r\n  );\r\n}\r\n\r\nlet lastSpokenTime = 0;\r\nlet cooldown = 1000; // 1 second cooldown to prevent overlap\r\n\r\nfunction speakFeedback(msg) {\r\n  const now = Date.now();\r\n\r\n  // Prevent overlapping or repeating too fast\r\n  if (now - lastSpokenTime < cooldown) return;\r\n  lastSpokenTime = now;\r\n\r\n  // Cancel any ongoing speech\r\n  window.speechSynthesis.cancel();\r\n\r\n  const speech = new SpeechSynthesisUtterance(msg);\r\n  speech.volume = 1;\r\n  speech.pitch = 1;\r\n  speech.rate = 1;\r\n  window.speechSynthesis.speak(speech);\r\n}\r\n\r\n// Helper to get x/y of a keypoint\r\nfunction getXY(keypoints, name) {\r\n  const kp = keypoints.find((k) => k.name === name);\r\n  return { x: kp?.x || 0, y: kp?.y || 0, score: kp?.score || 0 };\r\n}\r\nfunction getAngle(A, B, C) {\r\n  // Vectors: BA and BC\r\n  const BAx = A.x - B.x;\r\n  const BAy = A.y - B.y;\r\n  const BCx = C.x - B.x;\r\n  const BCy = C.y - B.y;\r\n\r\n  const dotProduct = BAx * BCx + BAy * BCy;\r\n  const magBA = Math.sqrt(BAx ** 2 + BAy ** 2);\r\n  const magBC = Math.sqrt(BCx ** 2 + BCy ** 2);\r\n\r\n  if (magBA === 0 || magBC === 0) return 0;\r\n\r\n  const angleRad = Math.acos(dotProduct / (magBA * magBC));\r\n  return angleRad * (180 / Math.PI); // Convert to degrees\r\n}\r\n\r\n// Basic keypoint reliability check\r\nfunction isReliable(kp, threshold = 0.5) {\r\n  return kp.score >= threshold;\r\n}\r\n\r\n// Exercise handlers\r\nconst exerciseHandlers = {\r\n  squat: (k, state) => {\r\n    const lHip = getXY(k, \"left_hip\");\r\n    const lKnee = getXY(k, \"left_knee\");\r\n    const lAnkle = getXY(k, \"left_ankle\");\r\n    const rHip = getXY(k, \"right_hip\");\r\n    const rKnee = getXY(k, \"right_knee\");\r\n    const rAnkle = getXY(k, \"right_ankle\");\r\n\r\n    // Ensure data is reliable\r\n    if (\r\n      !isReliable(lHip) ||\r\n      !isReliable(lKnee) ||\r\n      !isReliable(lAnkle) ||\r\n      !isReliable(rHip) ||\r\n      !isReliable(rKnee) ||\r\n      !isReliable(rAnkle)\r\n    )\r\n      return {};\r\n\r\n    // Helper: Calculate knee angle\r\n    const getAngle = (a, b, c) => {\r\n      const ab = { x: a.x - b.x, y: a.y - b.y };\r\n      const cb = { x: c.x - b.x, y: c.y - b.y };\r\n      const dot = ab.x * cb.x + ab.y * cb.y;\r\n      const magAB = Math.hypot(ab.x, ab.y);\r\n      const magCB = Math.hypot(cb.x, cb.y);\r\n      const angle = Math.acos(dot / (magAB * magCB));\r\n      return (angle * 180) / Math.PI;\r\n    };\r\n\r\n    const leftKneeAngle = getAngle(lHip, lKnee, lAnkle);\r\n    const rightKneeAngle = getAngle(rHip, rKnee, rAnkle);\r\n    const avgKneeAngle = (leftKneeAngle + rightKneeAngle) / 2;\r\n\r\n    const isDown = avgKneeAngle < 100; // <100° indicates squat bottom\r\n    const isUp = avgKneeAngle > 160; // >160° indicates standing\r\n\r\n    // DOWN phase\r\n    if (!state.down) {\r\n      if (isDown) {\r\n        state.downCount = (state.downCount || 0) + 1;\r\n        if (state.downCount > 4) {\r\n          state.down = true;\r\n          state.downCount = 0;\r\n          speakFeedback(\"Good depth!\");\r\n          return { feedback: \"Squat depth reached!\", repCounted: false };\r\n        }\r\n      } else {\r\n        state.downCount = 0;\r\n        return { feedback: \"Go deeper!\", scorePenalty: 1 };\r\n      }\r\n    }\r\n\r\n    // UP phase\r\n    else {\r\n      if (isUp) {\r\n        state.upCount = (state.upCount || 0) + 1;\r\n        if (state.upCount > 4) {\r\n          state.down = false;\r\n          state.upCount = 0;\r\n          speakFeedback(\"Squat counted!\");\r\n          return { feedback: \"Squat counted!\", repCounted: true };\r\n        }\r\n      } else {\r\n        state.upCount = 0;\r\n      }\r\n    }\r\n\r\n    return {};\r\n  },\r\n\r\n  jump: (k, state) => {\r\n    const hip = getXY(k, \"left_hip\");\r\n    if (!isReliable(hip)) return {};\r\n\r\n    if (state.prevHipY == null) state.prevHipY = hip.y;\r\n\r\n    const jumpHeight = state.prevHipY - hip.y;\r\n    const jumpUp = jumpHeight > 20;\r\n    const weakJump = jumpHeight > 5 && jumpHeight <= 20; // Low effort jump\r\n    const land = hip.y - state.prevHipY > 10;\r\n\r\n    // Weak jump form penalty\r\n    if (!state.jumping && weakJump) {\r\n      speakFeedback(\"Jump higher!\");\r\n      return {\r\n        feedback: \"Jump higher!\",\r\n        scorePenalty: 1,\r\n        repCounted: false,\r\n      };\r\n    }\r\n\r\n    // Good jump detected\r\n    if (!state.jumping && jumpUp) {\r\n      state.jumping = true;\r\n      speakFeedback(\"Nice jump!\");\r\n      return { feedback: \"Nice jump!\" };\r\n    }\r\n\r\n    // Landing after jump\r\n    if (state.jumping && land) {\r\n      state.jumping = false;\r\n      speakFeedback(\"Jump counted!\");\r\n      return { feedback: \"Jump counted!\", repCounted: true };\r\n    }\r\n\r\n    state.prevHipY = hip.y;\r\n    return {};\r\n  },\r\n\r\n  pushup: (k, state) => {\r\n    const shoulder = getXY(k, \"left_shoulder\");\r\n    const elbow = getXY(k, \"left_elbow\");\r\n    const wrist = getXY(k, \"left_wrist\");\r\n    const hip = getXY(k, \"left_hip\");\r\n\r\n    if (\r\n      !isReliable(shoulder) ||\r\n      !isReliable(elbow) ||\r\n      !isReliable(wrist) ||\r\n      !isReliable(hip)\r\n    )\r\n      return {};\r\n\r\n    // Helper: calculate angle between 3 points\r\n    const getAngle = (a, b, c) => {\r\n      const ab = { x: a.x - b.x, y: a.y - b.y };\r\n      const cb = { x: c.x - b.x, y: c.y - b.y };\r\n      const dot = ab.x * cb.x + ab.y * cb.y;\r\n      const magAB = Math.hypot(ab.x, ab.y);\r\n      const magCB = Math.hypot(cb.x, cb.y);\r\n      const angle = Math.acos(dot / (magAB * magCB));\r\n      return (angle * 180) / Math.PI;\r\n    };\r\n\r\n    const elbowAngle = getAngle(shoulder, elbow, wrist);\r\n    const bodyAngle = getAngle(shoulder, hip, { x: hip.x, y: hip.y + 0.1 }); // vertical approx\r\n\r\n    // Thresholds for down/up phase:\r\n    const downThreshold = 90; // elbow angle less than 90° means pushup down phase\r\n    const upThreshold = 160; // elbow angle more than 160° means pushup up phase\r\n\r\n    state.downCount = state.downCount || 0;\r\n    state.upCount = state.upCount || 0;\r\n\r\n    // Detect pushup DOWN phase\r\n    if (!state.down) {\r\n      if (elbowAngle < downThreshold) {\r\n        state.downCount++;\r\n        if (state.downCount > 2) {\r\n          state.down = true;\r\n          state.downCount = 0;\r\n          speakFeedback(\"Good pushup depth!\");\r\n          return { feedback: \"Good pushup depth!\", repCounted: false };\r\n        }\r\n      } else {\r\n        state.downCount = 0;\r\n        return { feedback: \"Lower your chest!\", scorePenalty: 1 };\r\n      }\r\n    }\r\n    // Detect pushup UP phase\r\n    else {\r\n      if (elbowAngle > upThreshold) {\r\n        state.upCount++;\r\n        if (state.upCount > 4) {\r\n          state.down = false;\r\n          state.upCount = 0;\r\n          speakFeedback(\"Pushup counted!\");\r\n          return { feedback: \"Pushup counted!\", repCounted: true };\r\n        }\r\n      } else {\r\n        state.upCount = 0;\r\n      }\r\n    }\r\n\r\n    return {};\r\n  },\r\n\r\n  plank: (k, state, deltaTime) => {\r\n    const head = getXY(k, \"head\") || getXY(k, \"nose\");\r\n    const shoulder = getXY(k, \"left_shoulder\");\r\n    const hip = getXY(k, \"left_hip\");\r\n\r\n    if (!isReliable(head) || !isReliable(shoulder) || !isReliable(hip)) {\r\n      state.plankHoldTime = 0; // reset if bad frame\r\n      state.lastSecondReported = 0; // reset feedback tracking\r\n      return {};\r\n    }\r\n\r\n    const hipDrop = hip.y - shoulder.y;\r\n    const headLift = head.y - shoulder.y;\r\n\r\n    if (hipDrop > 50) {\r\n      speakFeedback(\"Lift your hips a bit!\");\r\n      state.plankHoldTime = 0;\r\n      state.lastSecondReported = 0;\r\n      return { feedback: \"Lift your hips a bit!\", scorePenalty: 1 };\r\n    }\r\n\r\n    if (headLift < -40) {\r\n      speakFeedback(\"Lower your head slightly!\");\r\n      state.plankHoldTime = 0;\r\n      state.lastSecondReported = 0;\r\n      return { feedback: \"Lower your head slightly!\", scorePenalty: 1 };\r\n    }\r\n\r\n    // Accumulate plank hold time\r\n    state.plankHoldTime = (state.plankHoldTime || 0) + deltaTime;\r\n\r\n    // Calculate current whole seconds held\r\n    const secondsHeld = Math.floor(state.plankHoldTime / 1000);\r\n\r\n    // Provide feedback only when a new whole second is reached\r\n    if (secondsHeld > (state.lastSecondReported || 0)) {\r\n      state.lastSecondReported = secondsHeld;\r\n      speakFeedback(`Plank held: ${secondsHeld} seconds`);\r\n    }\r\n\r\n    if (state.plankHoldTime >= 10000) {\r\n      // 10 seconds\r\n      speakFeedback(\"Plank hold complete!\");\r\n      state.plankHoldTime = 0; // reset for next rep\r\n      state.lastSecondReported = 0;\r\n      return { feedback: \"Plank complete!\", repCounted: true };\r\n    }\r\n\r\n    return { feedback: `Good plank hold! ${secondsHeld}s`, repCounted: false };\r\n  },\r\n};\r\nlet lastStandInViewTime = 0;\r\nexport async function startPoseDetection(\r\n  videoElement,\r\n  exercise,\r\n  targetReps,\r\n  feedbackCallback = null,\r\n  userInfo\r\n) {\r\n  if (!detector) await loadModel();\r\n\r\n  if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {\r\n    await new Promise((resolve) => {\r\n      const checkReady = () => {\r\n        if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {\r\n          resolve();\r\n        } else {\r\n          requestAnimationFrame(checkReady); // Keep checking\r\n        }\r\n      };\r\n      videoElement.onloadedmetadata = checkReady;\r\n      checkReady();\r\n    });\r\n  }\r\n\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.width = videoElement.videoWidth;\r\n  canvas.height = videoElement.videoHeight;\r\n  document.body.appendChild(canvas);\r\n  const ctx = canvas.getContext(\"2d\");\r\n\r\n  let totalScore = 500;\r\n  let badFormCount = 0;\r\n  let repCount = 0;\r\n  const state = {};\r\n  const MET_VALUES = {\r\n    pushup: 8,\r\n    squat: 7,\r\n    plank: 5,\r\n    jumping_jack: 8,\r\n    // add more as needed\r\n  };\r\n  let workoutComplete = false; // ✅ Add flag to stop detection\r\n\r\n  const workoutStartTime = Date.now();\r\n\r\n  return new Promise((resolve) => {\r\n    const timeout = setTimeout(() => {\r\n      document.body.removeChild(canvas);\r\n      return resolve(null);\r\n    }, 300000);\r\n\r\n    const detect = async () => {\r\n      if (workoutComplete) return; // ✅ Stop further frames\r\n\r\n      const poses = await detector.estimatePoses(videoElement);\r\n\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n      ctx.font = \"20px Arial\";\r\n      if (\r\n        !poses ||\r\n        !Array.isArray(poses) ||\r\n        poses.length === 0 ||\r\n        !poses[0]?.keypoints ||\r\n        poses[0].keypoints.length === 0\r\n      ) {\r\n        ctx.fillStyle = \"red\";\r\n\r\n        const now = Date.now();\r\n        if (now - lastStandInViewTime > 4000) {\r\n          lastStandInViewTime = now;\r\n        }\r\n\r\n        requestAnimationFrame(detect);\r\n        return;\r\n      }\r\n\r\n      const pose = poses[0];\r\n\r\n      const handler = exerciseHandlers[exercise];\r\n      if (!handler) throw new Error(\"Unsupported exercise: \" + exercise);\r\n\r\n      const result = handler(pose.keypoints, state);\r\n\r\n      if (result.feedback) {\r\n        ctx.fillStyle = result.scorePenalty ? \"red\" : \"green\";\r\n        ctx.fillText(result.feedback, 10, 30);\r\n        speakFeedback(result.feedback);\r\n      }\r\n\r\n      if (result.scorePenalty) {\r\n        totalScore -= result.scorePenalty;\r\n      }\r\n\r\n      if (result.repCounted) {\r\n        repCount++;\r\n        speakFeedback(`Rep ${repCount} completed!`);\r\n        if (result.scorePenalty) {\r\n          badFormCount++; // Count bad form once per rep\r\n        }\r\n      }\r\n\r\n      if (typeof feedbackCallback === \"function\") {\r\n        feedbackCallback({\r\n          reps: repCount,\r\n          formFeedback: result.feedback,\r\n        });\r\n      }\r\n\r\n      if (repCount >= targetReps) {\r\n        workoutComplete = true; // ✅ Set flag to stop further detection\r\n        clearTimeout(timeout);\r\n        document.body.removeChild(canvas);\r\n\r\n        window.speechSynthesis.cancel();\r\n\r\n        const workoutEndTime = Date.now();\r\n        const durationMinutes = (workoutEndTime - workoutStartTime) / 60000;\r\n\r\n        let rawAccuracy = ((targetReps - badFormCount) / targetReps) * 100;\r\n        let adjustedAccuracy = Math.max(30, Math.min(rawAccuracy, 95)); // clamp between 30 and 95\r\n\r\n        let level = \"\";\r\n        if (adjustedAccuracy < 40) level = \"Weak\";\r\n        else if (adjustedAccuracy < 60) level = \"Beginner\";\r\n        else if (adjustedAccuracy < 80) level = \"Intermediate\";\r\n        else level = \"Advanced\";\r\n\r\n        const formQuality = badFormCount / targetReps;\r\n        console.log(\"Target Reps:\", targetReps);\r\n        console.log(\"Bad Form Count:\", badFormCount);\r\n        console.log(\"Form Quality:\", formQuality);\r\n\r\n        let feedback = \"Perfect form!\";\r\n        if (formQuality > 0.5) {\r\n          feedback = \"Work on your form!\";\r\n        } else if (formQuality > 0.25) {\r\n          feedback = \"Try better form next time!\";\r\n        } else if (formQuality > 0.1) {\r\n          feedback = \"Pretty good form!\";\r\n        }\r\n\r\n        // Calories calculation with gender factor\r\n        const genderFactor =\r\n          userInfo?.gender?.toLowerCase() === \"male\" ? 1 : 0.95;\r\n        const met = MET_VALUES[exercise.toLowerCase()] || 6;\r\n        const caloriesBurned =\r\n          met *\r\n          (userInfo?.weight || 70) *\r\n          (durationMinutes / 60) *\r\n          genderFactor;\r\n\r\n        return resolve({\r\n          score: Math.max(0, totalScore),\r\n          accuracy: Math.floor(adjustedAccuracy),\r\n          xp: Math.floor(Math.max(0, totalScore * 0.8)),\r\n          feedback:\r\n            badFormCount > 0 ? \"Try better form next time!\" : \"Perfect form!\",\r\n          reps: repCount,\r\n          badFormCount,\r\n          calories: caloriesBurned.toFixed(2),\r\n          durationMinutes: durationMinutes.toFixed(2),\r\n        });\r\n      }\r\n\r\n      requestAnimationFrame(detect);\r\n    };\r\n\r\n    detect();\r\n  });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}