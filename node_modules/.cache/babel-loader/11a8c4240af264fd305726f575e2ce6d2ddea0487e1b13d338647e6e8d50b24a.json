{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { makeMatMulPackedSource, makeMatMulPackedVec4Source } from './matmul_packed_webgpu';\nimport { typeSnippet } from './webgpu_program';\nimport { computeDispatch, computeWorkgroupSizeForConv2d, computeWorkPerThreadForConv2d } from './webgpu_util';\nfunction conv2dTransposeCommonSnippet() {\n  let innerElementSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n  const getWSnippet = innerElementSize => {\n    switch (innerElementSize) {\n      case 1:\n        return 'return W[getIndexFromCoords4D(coord, uniforms.wShape)];';\n      case 4:\n        return \"\\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\\n            return vec4<f32>(v0, v1, v2, v3);\\n            \";\n      default:\n        throw new Error(\"innerElementSize \".concat(innerElementSize, \" is not supported.\"));\n    }\n  };\n  const readASnippet = \"\\n      let outRow = row / uniforms.outShape[2];\\n      let outCol = row % uniforms.outShape[2];\\n\\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\\n        return \".concat(typeSnippet(innerElementSize), \"(0.0);\\n      }\\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\\n        return \").concat(typeSnippet(innerElementSize), \"(0.0);\\n      }\\n      let coord = vec4<i32>(\\n          batch,\\n          i32(xR),\\n          i32(xC),\\n          col % uniforms.outBackprop[3]);\\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/\").concat(innerElementSize, \"];\");\n  const sampleA = \"if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\\n        \".concat(readASnippet, \"\\n      }\\n      return \").concat(typeSnippet(innerElementSize), \"(0.0);\");\n  const userCode = \"\\n  fn mm_readA(batch: i32, row : i32, col : i32) -> \".concat(typeSnippet(innerElementSize), \" {\\n    \").concat(sampleA, \"\\n  }\\n\\n  fn mm_readB(batch: i32, row : i32, col : i32) -> \").concat(typeSnippet(innerElementSize), \" {\\n    let coordX = uniforms.filterDims.x - 1 -\\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\\n    let coordY = uniforms.filterDims.y - 1 -\\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\\n        coordX >= 0 && coordY >= 0) {\\n      let rowInner = row % uniforms.outBackprop[3];\\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\\n      \").concat(getWSnippet(innerElementSize), \"\\n    }\\n    return \").concat(typeSnippet(innerElementSize), \"(0.0);\\n  }\\n\\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : \").concat(typeSnippet(innerElementSize), \") {\\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\\n      var value = valueInput;\\n      let outCoord = vec4<i32>(\\n          batch,\\n          row / uniforms.outShape[2],\\n          row % uniforms.outShape[2],\\n          col);\\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/\").concat(innerElementSize, \"] = value;\\n    }\\n  }\");\n  return userCode;\n}\nexport class Conv2DDerInputMMProgram {\n  constructor(convInfo) {\n    this.variableNames = ['x', 'W'];\n    this.uniforms = 'filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,';\n    this.outputShape = convInfo.inShape;\n    util.assert(convInfo.dataFormat === 'channelsLast', () => 'TODO: NCHW is unimplemented');\n    this.isVec4 = convInfo.inChannels % 4 === 0 && convInfo.outChannels % 4 === 0;\n    this.dispatchLayout = {\n      x: [3],\n      y: [1, 2],\n      z: [0]\n    };\n    this.workgroupSize = computeWorkgroupSizeForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);\n    this.elementsPerThread = computeWorkPerThreadForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);\n    if (this.isVec4) {\n      this.outputComponent = 4;\n      this.variableComponents = [4, 1];\n    }\n    this.shaderKey = \"conv2DDerInputMM_\".concat(this.isVec4, \"_\").concat(this.elementsPerThread);\n  }\n  getUserCode() {\n    const matMulSource = this.isVec4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize) : makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize);\n    const userCode = \"\\n    \".concat(conv2dTransposeCommonSnippet(this.isVec4 ? 4 : 1), \"\\n    \").concat(matMulSource, \"\\n    \");\n    return userCode;\n  }\n}","map":{"version":3,"names":["util","makeMatMulPackedSource","makeMatMulPackedVec4Source","typeSnippet","computeDispatch","computeWorkgroupSizeForConv2d","computeWorkPerThreadForConv2d","conv2dTransposeCommonSnippet","innerElementSize","arguments","length","undefined","getWSnippet","Error","concat","readASnippet","sampleA","userCode","Conv2DDerInputMMProgram","constructor","convInfo","variableNames","uniforms","outputShape","inShape","assert","dataFormat","isVec4","inChannels","outChannels","dispatchLayout","x","y","z","workgroupSize","elementsPerThread","dispatch","outputComponent","variableComponents","shaderKey","getUserCode","matMulSource"],"sources":["D:\\Fitness WebApp\\tfjs-backend-webgpu\\src\\conv_backprop_mm_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {makeMatMulPackedSource, makeMatMulPackedVec4Source} from './matmul_packed_webgpu';\nimport {typeSnippet, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, computeWorkgroupSizeForConv2d, computeWorkPerThreadForConv2d} from './webgpu_util';\n\nfunction conv2dTransposeCommonSnippet(innerElementSize = 4) {\n  const getWSnippet = (innerElementSize: number) => {\n    switch (innerElementSize) {\n      case 1:\n        return 'return W[getIndexFromCoords4D(coord, uniforms.wShape)];';\n      case 4:\n        return `\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;\n      default:\n        throw new Error(\n            `innerElementSize ${innerElementSize} is not supported.`);\n    }\n  };\n\n  const readASnippet = `\n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${typeSnippet(innerElementSize)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${typeSnippet(innerElementSize)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${\n      innerElementSize}];`;\n\n  const sampleA = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${readASnippet}\n      }\n      return ${typeSnippet(innerElementSize)}(0.0);`;\n\n  const userCode = `\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ${\n      typeSnippet(innerElementSize)} {\n    ${sampleA}\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ${\n      typeSnippet(innerElementSize)} {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${getWSnippet(innerElementSize)}\n    }\n    return ${typeSnippet(innerElementSize)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${\n      typeSnippet(innerElementSize)}) {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${\n      innerElementSize}] = value;\n    }\n  }`;\n  return userCode;\n}\n\nexport class Conv2DDerInputMMProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x', 'W'];\n  variableComponents: number[];\n  uniforms =\n      'filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,';\n  workgroupSize: [number, number, number];\n  elementsPerThread: [number, number, number];\n  isVec4?: boolean;\n  outputComponent: number;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    util.assert(\n        convInfo.dataFormat === 'channelsLast',\n        () => 'TODO: NCHW is unimplemented');\n    this.isVec4 =\n        convInfo.inChannels % 4 === 0 && convInfo.outChannels % 4 === 0;\n    this.dispatchLayout = {x: [3], y: [1, 2], z: [0]};\n    this.workgroupSize = computeWorkgroupSizeForConv2d(\n        this.dispatchLayout, this.outputShape, this.isVec4);\n    this.elementsPerThread = computeWorkPerThreadForConv2d(\n        this.dispatchLayout, this.outputShape, this.isVec4);\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize,\n        this.elementsPerThread);\n\n    if (this.isVec4) {\n      this.outputComponent = 4;\n      this.variableComponents = [4, 1];\n    }\n\n    this.shaderKey =\n        `conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`;\n  }\n\n  getUserCode(): string {\n    const matMulSource = this.isVec4 ?\n        makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize) :\n        makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize);\n    const userCode = `\n    ${conv2dTransposeCommonSnippet(this.isVec4 ? 4 : 1)}\n    ${matMulSource}\n    `;\n    return userCode;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAsBA,IAAI,QAAO,uBAAuB;AAExD,SAAQC,sBAAsB,EAAEC,0BAA0B,QAAO,wBAAwB;AACzF,SAAQC,WAAW,QAAsB,kBAAkB;AAC3D,SAAQC,eAAe,EAAEC,6BAA6B,EAAEC,6BAA6B,QAAO,eAAe;AAE3G,SAASC,4BAA4BA,CAAA,EAAqB;EAAA,IAApBC,gBAAgB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EACxD,MAAMG,WAAW,GAAIJ,gBAAwB,IAAI;IAC/C,QAAQA,gBAAgB;MACtB,KAAK,CAAC;QACJ,OAAO,yDAAyD;MAClE,KAAK,CAAC;QACJ;MAUF;QACE,MAAM,IAAIK,KAAK,qBAAAC,MAAA,CACSN,gBAAgB,uBAAoB,CAAC;;EAEnE,CAAC;EAED,MAAMO,YAAY,mgBAAAD,MAAA,CASHX,WAAW,CAACK,gBAAgB,CAAC,sHAAAM,MAAA,CAG7BX,WAAW,CAACK,gBAAgB,CAAC,sNAAAM,MAAA,CAQxCN,gBAAgB,OAAI;EAExB,MAAMQ,OAAO,0EAAAF,MAAA,CACLC,YAAY,8BAAAD,MAAA,CAEPX,WAAW,CAACK,gBAAgB,CAAC,WAAQ;EAElD,MAAMS,QAAQ,2DAAAH,MAAA,CAEVX,WAAW,CAACK,gBAAgB,CAAC,cAAAM,MAAA,CAC7BE,OAAO,kEAAAF,MAAA,CAIPX,WAAW,CAACK,gBAAgB,CAAC,2cAAAM,MAAA,CAS3BF,WAAW,CAACJ,gBAAgB,CAAC,0BAAAM,MAAA,CAExBX,WAAW,CAACK,gBAAgB,CAAC,kFAAAM,MAAA,CAIpCX,WAAW,CAACK,gBAAgB,CAAC,4TAAAM,MAAA,CAS7BN,gBAAgB,2BAElB;EACF,OAAOS,QAAQ;AACjB;AAEA,OAAM,MAAOC,uBAAuB;EAclCC,YAAYC,QAAiC;IAT7C,KAAAC,aAAa,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;IAE1B,KAAAC,QAAQ,GACJ,2IAA2I;IAO7I,IAAI,CAACC,WAAW,GAAGH,QAAQ,CAACI,OAAO;IAEnCxB,IAAI,CAACyB,MAAM,CACPL,QAAQ,CAACM,UAAU,KAAK,cAAc,EACtC,MAAM,6BAA6B,CAAC;IACxC,IAAI,CAACC,MAAM,GACPP,QAAQ,CAACQ,UAAU,GAAG,CAAC,KAAK,CAAC,IAAIR,QAAQ,CAACS,WAAW,GAAG,CAAC,KAAK,CAAC;IACnE,IAAI,CAACC,cAAc,GAAG;MAACC,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC;IAAC,CAAC;IACjD,IAAI,CAACC,aAAa,GAAG7B,6BAA6B,CAC9C,IAAI,CAACyB,cAAc,EAAE,IAAI,CAACP,WAAW,EAAE,IAAI,CAACI,MAAM,CAAC;IACvD,IAAI,CAACQ,iBAAiB,GAAG7B,6BAA6B,CAClD,IAAI,CAACwB,cAAc,EAAE,IAAI,CAACP,WAAW,EAAE,IAAI,CAACI,MAAM,CAAC;IAEvD,IAAI,CAACS,QAAQ,GAAGhC,eAAe,CAC3B,IAAI,CAAC0B,cAAc,EAAE,IAAI,CAACP,WAAW,EAAE,IAAI,CAACW,aAAa,EACzD,IAAI,CAACC,iBAAiB,CAAC;IAE3B,IAAI,IAAI,CAACR,MAAM,EAAE;MACf,IAAI,CAACU,eAAe,GAAG,CAAC;MACxB,IAAI,CAACC,kBAAkB,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;;IAGlC,IAAI,CAACC,SAAS,uBAAAzB,MAAA,CACU,IAAI,CAACa,MAAM,OAAAb,MAAA,CAAI,IAAI,CAACqB,iBAAiB,CAAE;EACjE;EAEAK,WAAWA,CAAA;IACT,MAAMC,YAAY,GAAG,IAAI,CAACd,MAAM,GAC5BzB,0BAA0B,CAAC,IAAI,CAACiC,iBAAiB,EAAE,IAAI,CAACD,aAAa,CAAC,GACtEjC,sBAAsB,CAAC,IAAI,CAACkC,iBAAiB,EAAE,IAAI,CAACD,aAAa,CAAC;IACtE,MAAMjB,QAAQ,YAAAH,MAAA,CACZP,4BAA4B,CAAC,IAAI,CAACoB,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,YAAAb,MAAA,CACjD2B,YAAY,WACb;IACD,OAAOxB,QAAQ;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}