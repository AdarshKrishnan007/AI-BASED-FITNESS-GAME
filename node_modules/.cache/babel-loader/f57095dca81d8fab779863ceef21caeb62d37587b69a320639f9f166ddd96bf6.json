{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { atomicAddSnippet } from './shader_util';\nimport { dataTypeToGPUType, getCoordsDataType, getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nexport class ScatterProgram {\n  constructor(flattenXShape, sliceDim, indicesRank, updatesRank, strides, shape, outputDtype) {\n    let sumDupeIndices = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;\n    this.variableNames = ['updates', 'indices'];\n    this.workgroupSize = [64, 1, 1];\n    this.atomic = true;\n    this.outputShape = shape;\n    this.type = outputDtype;\n    this.sumDupeIndices = sumDupeIndices;\n    this.dispatchLayout = flatDispatchLayout(flattenXShape);\n    // Dispatching based on |updates| shape instead of output shape.\n    this.dispatch = computeDispatch(this.dispatchLayout, flattenXShape, this.workgroupSize);\n    this.sliceDimGreaterThanOne = sliceDim > 1;\n    this.shaderKey = \"scatter_\".concat(indicesRank, \"_\").concat(updatesRank, \"_\").concat(this.sliceDimGreaterThanOne, \"_\").concat(outputDtype, \"_\").concat(sumDupeIndices, \"_\").concat(strides.length);\n    const stridesType = getCoordsDataType(strides.length);\n    this.uniforms = \"sliceDim : i32, strides: \".concat(stridesType, \", updatesSize: i32,\");\n    this.updatesRank = updatesRank;\n    this.indicesRank = indicesRank;\n  }\n  getUserCode() {\n    let indicesString = '';\n    if (this.indicesRank === 1) {\n      indicesString = 'coords[0]';\n    } else if (this.indicesRank === 2) {\n      indicesString = 'coords[0], j';\n    }\n    const indicesSnippet = \"getIndices(\".concat(indicesString, \")\");\n    const strideString = this.sliceDimGreaterThanOne ? 'uniforms.strides[j]' : 'uniforms.strides';\n    let outCoordsString = '';\n    let getUpdatesCoordsFromFlatIndex = '';\n    if (this.dispatchLayout.x.length === 1) {\n      outCoordsString = 'flattenedIndex';\n      getUpdatesCoordsFromFlatIndex = \"\\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\\n        return index;\\n      }\\n      \";\n    } else if (this.dispatchLayout.x.length === 2) {\n      outCoordsString = 'vec2<i32>(flattenedIndex, coords[1])';\n      getUpdatesCoordsFromFlatIndex = \"\\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\\n        // 2D tensor with all values equal to that. By design, its size must be\\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\\n        // gives the other.\\n        let sliceSize = uniforms.outShape[1];\\n        let d0 = index / sliceSize;\\n        let d1 = index - d0 * sliceSize;\\n        return vec2<i32>(d0, d1);\\n      }\\n      \";\n    }\n    const updatesString = Array.from({\n      length: this.updatesRank\n    }, (_, idx) => \"coords[\".concat(idx, \"]\"));\n    const updatesSnippet = \"getUpdates(\".concat(updatesString.join(', '), \")\");\n    const userCode = \"\\n    \".concat(getUpdatesCoordsFromFlatIndex, \"\\n      \").concat(main('index'), \" {\\n        if (index < uniforms.updatesSize) {\\n          let coords = getUpdatesCoordsFromFlatIndex(index);\\n          var flattenedIndex = 0;\\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\\n            let indexInside = i32(round(\").concat(indicesSnippet, \"));\\n            flattenedIndex = flattenedIndex + indexInside * \").concat(strideString, \";\\n          }\\n          let updateValue =\\n              \").concat(dataTypeToGPUType(this.type), \"(\").concat(updatesSnippet, \");\\n          let flatIndex = getOutputIndexFromCoords(\").concat(outCoordsString, \");\\n\\n          \").concat(this.sumDupeIndices ? atomicAddSnippet('&result[flatIndex]', 'updateValue', this.type) : \"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));\", \"\\n        }\\n      }\");\n    return userCode;\n  }\n}","map":{"version":3,"names":["atomicAddSnippet","dataTypeToGPUType","getCoordsDataType","getMainHeaderString","main","computeDispatch","flatDispatchLayout","ScatterProgram","constructor","flattenXShape","sliceDim","indicesRank","updatesRank","strides","shape","outputDtype","sumDupeIndices","arguments","length","undefined","variableNames","workgroupSize","atomic","outputShape","type","dispatchLayout","dispatch","sliceDimGreaterThanOne","shaderKey","concat","stridesType","uniforms","getUserCode","indicesString","indicesSnippet","strideString","outCoordsString","getUpdatesCoordsFromFlatIndex","x","updatesString","Array","from","_","idx","updatesSnippet","join","userCode"],"sources":["D:\\Fitness WebApp\\tfjs-backend-webgpu\\src\\scatter_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType} from '@tensorflow/tfjs-core';\n\nimport {atomicAddSnippet} from './shader_util';\nimport {dataTypeToGPUType, getCoordsDataType, getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nexport class ScatterProgram implements WebGPUProgram {\n  variableNames = ['updates', 'indices'];\n  uniforms: string;\n  outputShape: number[];\n  sumDupeIndices: boolean;\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  updatesRank: number;\n  indicesRank: number;\n  sliceDimGreaterThanOne: boolean;\n  atomic = true;\n  type: DataType;\n\n  constructor(\n      flattenXShape: number[], sliceDim: number, indicesRank: number,\n      updatesRank: number, strides: number[], shape: number[],\n      outputDtype: DataType, sumDupeIndices = true) {\n    this.outputShape = shape;\n    this.type = outputDtype;\n    this.sumDupeIndices = sumDupeIndices;\n    this.dispatchLayout = flatDispatchLayout(flattenXShape);\n    // Dispatching based on |updates| shape instead of output shape.\n    this.dispatch =\n        computeDispatch(this.dispatchLayout, flattenXShape, this.workgroupSize);\n    this.sliceDimGreaterThanOne = sliceDim > 1;\n    this.shaderKey =\n        `scatter_${indicesRank}_${updatesRank}_${this.sliceDimGreaterThanOne}_${\n            outputDtype}_${sumDupeIndices}_${strides.length}`;\n    const stridesType = getCoordsDataType(strides.length);\n    this.uniforms =\n        `sliceDim : i32, strides: ${stridesType}, updatesSize: i32,`;\n    this.updatesRank = updatesRank;\n    this.indicesRank = indicesRank;\n  }\n\n  getUserCode(): string {\n    let indicesString = '';\n    if (this.indicesRank === 1) {\n      indicesString = 'coords[0]';\n    } else if (this.indicesRank === 2) {\n      indicesString = 'coords[0], j';\n    }\n    const indicesSnippet = `getIndices(${indicesString})`;\n\n    const strideString = this.sliceDimGreaterThanOne ? 'uniforms.strides[j]' :\n                                                       'uniforms.strides';\n\n    let outCoordsString = '';\n    let getUpdatesCoordsFromFlatIndex = '';\n    if (this.dispatchLayout.x.length === 1) {\n      outCoordsString = 'flattenedIndex';\n      getUpdatesCoordsFromFlatIndex = `\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      `;\n    } else if (this.dispatchLayout.x.length === 2) {\n      outCoordsString = 'vec2<i32>(flattenedIndex, coords[1])';\n      getUpdatesCoordsFromFlatIndex = `\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      `;\n    }\n    const updatesString =\n        Array.from({length: this.updatesRank}, (_, idx) => `coords[${idx}]`);\n    const updatesSnippet = `getUpdates(${updatesString.join(', ')})`;\n\n    const userCode = `\n    ${getUpdatesCoordsFromFlatIndex}\n      ${main('index')} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${indicesSnippet}));\n            flattenedIndex = flattenedIndex + indexInside * ${strideString};\n          }\n          let updateValue =\n              ${dataTypeToGPUType(this.type)}(${updatesSnippet});\n          let flatIndex = getOutputIndexFromCoords(${outCoordsString});\n\n          ${\n        this.sumDupeIndices ?\n            atomicAddSnippet(\n                '&result[flatIndex]', 'updateValue',\n                this.type as 'float32' | 'int32') :\n            `atomicStore(&result[flatIndex], bitcast<i32>(updateValue));`}\n        }\n      }`;\n    return userCode;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAmBA,SAAQA,gBAAgB,QAAO,eAAe;AAC9C,SAAQC,iBAAiB,EAAEC,iBAAiB,EAAEC,mBAAmB,IAAIC,IAAI,QAAsB,kBAAkB;AACjH,SAAQC,eAAe,EAAEC,kBAAkB,QAAO,eAAe;AAEjE,OAAM,MAAOC,cAAc;EAezBC,YACIC,aAAuB,EAAEC,QAAgB,EAAEC,WAAmB,EAC9DC,WAAmB,EAAEC,OAAiB,EAAEC,KAAe,EACvDC,WAAqB,EAAuB;IAAA,IAArBC,cAAc,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;IAjBhD,KAAAG,aAAa,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC;IAOtC,KAAAC,aAAa,GAA6B,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;IAIpD,KAAAC,MAAM,GAAG,IAAI;IAOX,IAAI,CAACC,WAAW,GAAGT,KAAK;IACxB,IAAI,CAACU,IAAI,GAAGT,WAAW;IACvB,IAAI,CAACC,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACS,cAAc,GAAGnB,kBAAkB,CAACG,aAAa,CAAC;IACvD;IACA,IAAI,CAACiB,QAAQ,GACTrB,eAAe,CAAC,IAAI,CAACoB,cAAc,EAAEhB,aAAa,EAAE,IAAI,CAACY,aAAa,CAAC;IAC3E,IAAI,CAACM,sBAAsB,GAAGjB,QAAQ,GAAG,CAAC;IAC1C,IAAI,CAACkB,SAAS,cAAAC,MAAA,CACClB,WAAW,OAAAkB,MAAA,CAAIjB,WAAW,OAAAiB,MAAA,CAAI,IAAI,CAACF,sBAAsB,OAAAE,MAAA,CAChEd,WAAW,OAAAc,MAAA,CAAIb,cAAc,OAAAa,MAAA,CAAIhB,OAAO,CAACK,MAAM,CAAE;IACzD,MAAMY,WAAW,GAAG5B,iBAAiB,CAACW,OAAO,CAACK,MAAM,CAAC;IACrD,IAAI,CAACa,QAAQ,+BAAAF,MAAA,CACmBC,WAAW,wBAAqB;IAChE,IAAI,CAAClB,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACD,WAAW,GAAGA,WAAW;EAChC;EAEAqB,WAAWA,CAAA;IACT,IAAIC,aAAa,GAAG,EAAE;IACtB,IAAI,IAAI,CAACtB,WAAW,KAAK,CAAC,EAAE;MAC1BsB,aAAa,GAAG,WAAW;KAC5B,MAAM,IAAI,IAAI,CAACtB,WAAW,KAAK,CAAC,EAAE;MACjCsB,aAAa,GAAG,cAAc;;IAEhC,MAAMC,cAAc,iBAAAL,MAAA,CAAiBI,aAAa,MAAG;IAErD,MAAME,YAAY,GAAG,IAAI,CAACR,sBAAsB,GAAG,qBAAqB,GACrB,kBAAkB;IAErE,IAAIS,eAAe,GAAG,EAAE;IACxB,IAAIC,6BAA6B,GAAG,EAAE;IACtC,IAAI,IAAI,CAACZ,cAAc,CAACa,CAAC,CAACpB,MAAM,KAAK,CAAC,EAAE;MACtCkB,eAAe,GAAG,gBAAgB;MAClCC,6BAA6B,2GAI5B;KACF,MAAM,IAAI,IAAI,CAACZ,cAAc,CAACa,CAAC,CAACpB,MAAM,KAAK,CAAC,EAAE;MAC7CkB,eAAe,GAAG,sCAAsC;MACxDC,6BAA6B,wgBAW5B;;IAEH,MAAME,aAAa,GACfC,KAAK,CAACC,IAAI,CAAC;MAACvB,MAAM,EAAE,IAAI,CAACN;IAAW,CAAC,EAAE,CAAC8B,CAAC,EAAEC,GAAG,eAAAd,MAAA,CAAec,GAAG,MAAG,CAAC;IACxE,MAAMC,cAAc,iBAAAf,MAAA,CAAiBU,aAAa,CAACM,IAAI,CAAC,IAAI,CAAC,MAAG;IAEhE,MAAMC,QAAQ,YAAAjB,MAAA,CACZQ,6BAA6B,cAAAR,MAAA,CAC3BzB,IAAI,CAAC,OAAO,CAAC,+PAAAyB,MAAA,CAKqBK,cAAc,uEAAAL,MAAA,CACMM,YAAY,iEAAAN,MAAA,CAG1D5B,iBAAiB,CAAC,IAAI,CAACuB,IAAI,CAAC,OAAAK,MAAA,CAAIe,cAAc,6DAAAf,MAAA,CACTO,eAAe,sBAAAP,MAAA,CAG5D,IAAI,CAACb,cAAc,GACfhB,gBAAgB,CACZ,oBAAoB,EAAE,aAAa,EACnC,IAAI,CAACwB,IAA2B,CAAC,gEACwB,yBAEjE;IACJ,OAAOsB,QAAQ;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}