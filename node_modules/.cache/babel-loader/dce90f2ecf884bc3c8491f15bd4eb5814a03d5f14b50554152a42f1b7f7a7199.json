{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { activationFnSnippet, biasActivationSnippet } from './activation_util';\nimport { makeMatMulPackedSource, makeMatMulPackedVec4Source, matMulReadFnSource } from './matmul_packed_webgpu';\nimport { atomicAddSnippet } from './shader_util';\nimport { getMainHeaderString as main, typeSnippet } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nexport class MatMulSplitKProgram {\n  constructor(outputShape, dimInner) {\n    let transposeA = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let transposeB = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    this.variableNames = ['A', 'B'];\n    this.uniforms = \"dimAOuter : i32, dimBOuter : i32, dimInner : i32,\";\n    this.workgroupSize = [8, 8, 1];\n    this.atomic = true;\n    this.splitedDimInner = 128;\n    util.assert(outputShape[0] === 1, () => 'MatMulSplitKProgram only supports batch = 1.');\n    this.outputShape = outputShape;\n    this.dispatchLayout = {\n      x: [2],\n      y: [1],\n      z: [0, 3]\n    };\n    const isVec4 = (transposeA && this.outputShape[1] % 4 === 0 || !transposeA && dimInner % 4 === 0) && this.outputShape[2] % 4 === 0;\n    this.elementsPerThread = [4, 4, this.splitedDimInner];\n    this.outputComponent = isVec4 ? 4 : 1;\n    if (!isVec4) {\n      if (this.outputShape[1] < 16) {\n        this.elementsPerThread[1] = 1;\n      }\n      if (this.outputShape[2] < 16) {\n        this.elementsPerThread[0] = 1;\n      }\n    }\n    this.dispatch = computeDispatch(this.dispatchLayout, [this.outputShape[0], this.outputShape[1], this.outputShape[2], dimInner], this.workgroupSize, this.elementsPerThread);\n    this.transposeA = transposeA;\n    this.transposeB = transposeB;\n    this.shaderKey = \"matMulSplitK_\".concat(transposeA, \"_\").concat(transposeB, \"_\").concat(this.elementsPerThread, \"_\").concat(this.outputComponent);\n  }\n  getUserCode() {\n    const component = this.outputComponent;\n    const userCode = \"\\n      \".concat(matMulReadFnSource(false, this.transposeB, false, false, false, component), \"\\n      fn mm_write(batch: i32, row : i32, col : i32, value : \").concat(typeSnippet(component), \") {\\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\\n          let coords = vec3<i32>(batch, row, col);\\n          let flatIndex = getOutputIndexFromCoords(coords);\\n          // The problem is that we should initialize output to zero before using.\\n          // Otherwise, the original value will be added to the result.\\n          for (var i = 0; i < \").concat(component, \"; i = i + 1) {\\n            \").concat(atomicAddSnippet('&result[flatIndex + i]', \"\".concat(component > 1 ? 'value[i]' : 'value'), 'float32'), \"\\n          }\\n        }\\n      }\\n      \").concat(component === 4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner) : makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner), \"\\n    \");\n    return userCode;\n  }\n}\nexport class BiasActivationProgram {\n  constructor(outputShape) {\n    let bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let activation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let preluActivationWeights = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this.uniforms = '';\n    this.variableNames = ['x'];\n    this.workgroupSize = [64, 1, 1];\n    this.size = true;\n    this.outputShape = outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.addBias = bias != null;\n    this.hasPreluActivationWeights = preluActivationWeights != null;\n    this.activation = activation;\n    if (this.addBias) {\n      this.variableNames.push('bias');\n    }\n    if (this.hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    this.shaderKey = \"biasActivation_\".concat(activation);\n  }\n  getUserCode() {\n    return \"\\n    \".concat(activationFnSnippet(this.activation, this.hasPreluActivationWeights), \"\\n    \").concat(main('index'), \" {\\n      if (index < uniforms.size) {\\n        let coords = getCoordsFromIndex(index);\\n        var value = getXByOutputIndex(index);\\n        \").concat(biasActivationSnippet(this.addBias, this.activation), \"\\n        setOutputAtIndex(index, value);\\n      }\\n    }\\n    \");\n  }\n}","map":{"version":3,"names":["util","activationFnSnippet","biasActivationSnippet","makeMatMulPackedSource","makeMatMulPackedVec4Source","matMulReadFnSource","atomicAddSnippet","getMainHeaderString","main","typeSnippet","computeDispatch","flatDispatchLayout","MatMulSplitKProgram","constructor","outputShape","dimInner","transposeA","arguments","length","undefined","transposeB","variableNames","uniforms","workgroupSize","atomic","splitedDimInner","assert","dispatchLayout","x","y","z","isVec4","elementsPerThread","outputComponent","dispatch","shaderKey","concat","getUserCode","component","userCode","BiasActivationProgram","bias","activation","preluActivationWeights","size","addBias","hasPreluActivationWeights","push"],"sources":["D:\\Fitness WebApp\\tfjs-backend-webgpu\\src\\matmul_splitK_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {activationFnSnippet, biasActivationSnippet} from './activation_util';\nimport {makeMatMulPackedSource, makeMatMulPackedVec4Source, matMulReadFnSource} from './matmul_packed_webgpu';\nimport {atomicAddSnippet} from './shader_util';\nimport {getMainHeaderString as main, typeSnippet, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nexport class MatMulSplitKProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['A', 'B'];\n  uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;\n  workgroupSize: [number, number, number] = [8, 8, 1];\n  elementsPerThread: [number, number, number];\n  transposeA: boolean;\n  transposeB: boolean;\n  atomic = true;\n  outputComponent: number;\n  splitedDimInner = 128;\n\n  constructor(\n      outputShape: [number, number, number], dimInner: number,\n      transposeA = false, transposeB = false) {\n    util.assert(\n        outputShape[0] === 1,\n        () => 'MatMulSplitKProgram only supports batch = 1.');\n    this.outputShape = outputShape;\n    this.dispatchLayout = {x: [2], y: [1], z: [0, 3]};\n    const isVec4 = (transposeA && this.outputShape[1] % 4 === 0 ||\n                    !transposeA && dimInner % 4 === 0) &&\n        this.outputShape[2] % 4 === 0;\n    this.elementsPerThread = [4, 4, this.splitedDimInner];\n    this.outputComponent = isVec4 ? 4 : 1;\n    if (!isVec4) {\n      if (this.outputShape[1] < 16) {\n        this.elementsPerThread[1] = 1;\n      }\n      if (this.outputShape[2] < 16) {\n        this.elementsPerThread[0] = 1;\n      }\n    }\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout,\n        [\n          this.outputShape[0], this.outputShape[1], this.outputShape[2],\n          dimInner\n        ],\n        this.workgroupSize, this.elementsPerThread);\n\n    this.transposeA = transposeA;\n    this.transposeB = transposeB;\n    this.shaderKey = `matMulSplitK_${transposeA}_${transposeB}_${\n        this.elementsPerThread}_${this.outputComponent}`;\n  }\n\n  getUserCode(): string {\n    const component = this.outputComponent;\n    const userCode = `\n      ${\n        matMulReadFnSource(\n            false, this.transposeB, false, false, false, component)}\n      fn mm_write(batch: i32, row : i32, col : i32, value : ${\n        typeSnippet(component)}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${component}; i = i + 1) {\n            ${\n        atomicAddSnippet(\n            '&result[flatIndex + i]', `${component > 1 ? 'value[i]' : 'value'}`,\n            'float32')}\n          }\n        }\n      }\n      ${\n        component === 4 ? makeMatMulPackedVec4Source(\n                              this.elementsPerThread, this.workgroupSize,\n                              this.transposeA, 32, true, this.splitedDimInner) :\n                          makeMatMulPackedSource(\n                              this.elementsPerThread, this.workgroupSize,\n                              this.transposeA, 32, true, this.splitedDimInner)}\n    `;\n    return userCode;\n  }\n}\n\nexport class BiasActivationProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  uniforms = '';\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  size = true;\n  private addBias: boolean;\n  private activation: backend_util.Activation;\n  private hasPreluActivationWeights: boolean;\n\n  constructor(\n      outputShape: number[], bias: TensorInfo = null,\n      activation: backend_util.Activation = null,\n      preluActivationWeights: TensorInfo = null) {\n    this.outputShape = outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.addBias = bias != null;\n    this.hasPreluActivationWeights = preluActivationWeights != null;\n    this.activation = activation;\n    if (this.addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (this.hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.shaderKey = `biasActivation_${activation}`;\n  }\n\n  getUserCode(): string {\n    return `\n    ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}\n    ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${biasActivationSnippet(this.addBias, this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}