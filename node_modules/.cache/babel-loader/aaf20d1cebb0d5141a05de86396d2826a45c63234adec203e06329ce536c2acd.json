{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nconst powOperatorSnippet = \"\\n  var powValue = 0.0;\\n  let basis = uniforms.bias + uniforms.alpha * sum;\\n  if (uniforms.beta == 0.5) {\\n    powValue = inverseSqrt(basis);\\n  } else if (uniforms.beta == 1.0) {\\n    powValue = 1.0 / basis;\\n  } else {\\n    powValue = exp(log(basis) * (-uniforms.beta));\\n  }\\n\";\nexport class LRNProgram {\n  constructor(xShape) {\n    this.outputShape = [];\n    this.variableNames = ['x'];\n    this.uniforms = 'radius : i32, bias : f32, alpha : f32, beta : f32,';\n    this.workgroupSize = [64, 1, 1];\n    this.size = true;\n    this.outputShape = xShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.shaderKey = 'lrn';\n  }\n  getUserCode() {\n    const userCode = \"\\n    \".concat(main('index'), \" {\\n      if (index < uniforms.size) {\\n        let coords = getOutputCoords();\\n        let b = coords[0];\\n        let r = coords[1];\\n        let c = coords[2];\\n        let d = coords[3];\\n\\n        let x = getX(b, r, c, d);\\n        var sum = 0.0;\\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\\n          let idx = d + i;\\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\\n            let z = getX(b, r, c, idx);\\n            sum = sum + z * z;\\n          }\\n        }\\n        \").concat(powOperatorSnippet, \"\\n\\n        setOutputAtIndex(index, x * powValue);\\n      }\\n    }\\n  \");\n    return userCode;\n  }\n}\nexport class LRNSharedProgram {\n  constructor(xShape, radius) {\n    this.outputShape = [];\n    this.variableNames = ['x'];\n    this.uniforms = 'radius : i32, bias : f32, alpha : f32, beta : f32,';\n    this.workgroupSize = [256, 1, 1];\n    this.maxAllowRadius = 16;\n    util.assert(radius <= this.maxAllowRadius, () => \"Radius must be less than or equal to \".concat(this.maxAllowRadius, \", current radius is \").concat(radius));\n    this.outputShape = xShape;\n    // The reason why not using this.workgroupSize[0] + 2 * maxAllowRadius here\n    // is to make sure that there is only one time global memory load access for\n    // each thread.\n    this.elementsPerWorkgroup = this.workgroupSize[0] - 2 * this.maxAllowRadius;\n    this.dispatchLayout = {\n      x: [3],\n      y: [2],\n      z: [0, 1]\n    };\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, [this.elementsPerWorkgroup, this.workgroupSize[1], this.workgroupSize[2]]);\n    this.shaderKey = 'lrn_shared';\n  }\n  getUserCode() {\n    const userCode = \"\\n    var <workgroup>lrnSub: array<f32, \".concat(this.workgroupSize[0], \">;\\n    const elementsPerWorkgroup = \").concat(this.elementsPerWorkgroup, \";\\n    const maxAllowRadius = \").concat(this.maxAllowRadius, \";\\n\\n    \").concat(main(), \" {\\n      let localDepth = i32(localId.x);\\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\\n      let b = i32(globalId.z) / uniforms.xShape[1];\\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\\n      let c = i32(globalId.y);\\n      let d = workgroupDepth + localDepth;\\n\\n      var x = 0.0;\\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\\n        x = getX(b, r, c, xDepth);\\n      }\\n      lrnSub[localDepth] = x;\\n      workgroupBarrier();\\n\\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\\n        var sum = 0.0;\\n        let index = localDepth + maxAllowRadius;\\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\\n          let z = lrnSub[index + i];\\n          sum = sum + z * z;\\n        }\\n        \").concat(powOperatorSnippet, \"\\n\\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\\n      }\\n    } \");\n    return userCode;\n  }\n}","map":{"version":3,"names":["util","getMainHeaderString","main","computeDispatch","flatDispatchLayout","powOperatorSnippet","LRNProgram","constructor","xShape","outputShape","variableNames","uniforms","workgroupSize","size","dispatchLayout","dispatch","shaderKey","getUserCode","userCode","concat","LRNSharedProgram","radius","maxAllowRadius","assert","elementsPerWorkgroup","x","y","z"],"sources":["D:\\Fitness WebApp\\tfjs-backend-webgpu\\src\\lrn_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\nimport {getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nconst powOperatorSnippet = `\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n`;\n\nexport class LRNProgram implements WebGPUProgram {\n  outputShape: number[] = [];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms = 'radius : i32, bias : f32, alpha : f32, beta : f32,';\n  workgroupSize: [number, number, number] = [64, 1, 1];\n  size = true;\n\n  constructor(xShape: number[]) {\n    this.outputShape = xShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.shaderKey = 'lrn';\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${powOperatorSnippet}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `;\n    return userCode;\n  }\n}\n\nexport class LRNSharedProgram implements WebGPUProgram {\n  outputShape: number[] = [];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms = 'radius : i32, bias : f32, alpha : f32, beta : f32,';\n  workgroupSize: [number, number, number] = [256, 1, 1];\n  maxAllowRadius = 16;\n  elementsPerWorkgroup: number;\n\n  constructor(xShape: number[], radius: number) {\n    util.assert(\n        radius <= this.maxAllowRadius,\n        () => `Radius must be less than or equal to ${\n            this.maxAllowRadius}, current radius is ${radius}`);\n\n    this.outputShape = xShape;\n    // The reason why not using this.workgroupSize[0] + 2 * maxAllowRadius here\n    // is to make sure that there is only one time global memory load access for\n    // each thread.\n    this.elementsPerWorkgroup = this.workgroupSize[0] - 2 * this.maxAllowRadius;\n    this.dispatchLayout = {x: [3], y: [2], z: [0, 1]};\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, [\n      this.elementsPerWorkgroup, this.workgroupSize[1], this.workgroupSize[2]\n    ]);\n    this.shaderKey = 'lrn_shared';\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${main()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${powOperatorSnippet}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `;\n    return userCode;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,IAAI,QAAO,uBAAuB;AAC1C,SAAQC,mBAAmB,IAAIC,IAAI,QAAsB,kBAAkB;AAC3E,SAAQC,eAAe,EAAEC,kBAAkB,QAAO,eAAe;AAEjE,MAAMC,kBAAkB,8RAUvB;AAED,OAAM,MAAOC,UAAU;EAUrBC,YAAYC,MAAgB;IAT5B,KAAAC,WAAW,GAAa,EAAE;IAI1B,KAAAC,aAAa,GAAG,CAAC,GAAG,CAAC;IACrB,KAAAC,QAAQ,GAAG,oDAAoD;IAC/D,KAAAC,aAAa,GAA6B,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;IACpD,KAAAC,IAAI,GAAG,IAAI;IAGT,IAAI,CAACJ,WAAW,GAAGD,MAAM;IACzB,IAAI,CAACM,cAAc,GAAGV,kBAAkB,CAAC,IAAI,CAACK,WAAW,CAAC;IAC1D,IAAI,CAACM,QAAQ,GAAGZ,eAAe,CAC3B,IAAI,CAACW,cAAc,EAAE,IAAI,CAACL,WAAW,EAAE,IAAI,CAACG,aAAa,CAAC;IAC9D,IAAI,CAACI,SAAS,GAAG,KAAK;EACxB;EAEAC,WAAWA,CAAA;IACT,MAAMC,QAAQ,YAAAC,MAAA,CACZjB,IAAI,CAAC,OAAO,CAAC,2gBAAAiB,MAAA,CAiBTd,kBAAkB,2EAKzB;IACC,OAAOa,QAAQ;EACjB;;AAGF,OAAM,MAAOE,gBAAgB;EAW3Bb,YAAYC,MAAgB,EAAEa,MAAc;IAV5C,KAAAZ,WAAW,GAAa,EAAE;IAI1B,KAAAC,aAAa,GAAG,CAAC,GAAG,CAAC;IACrB,KAAAC,QAAQ,GAAG,oDAAoD;IAC/D,KAAAC,aAAa,GAA6B,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;IACrD,KAAAU,cAAc,GAAG,EAAE;IAIjBtB,IAAI,CAACuB,MAAM,CACPF,MAAM,IAAI,IAAI,CAACC,cAAc,EAC7B,8CAAAH,MAAA,CACI,IAAI,CAACG,cAAc,0BAAAH,MAAA,CAAuBE,MAAM,CAAE,CAAC;IAE3D,IAAI,CAACZ,WAAW,GAAGD,MAAM;IACzB;IACA;IACA;IACA,IAAI,CAACgB,oBAAoB,GAAG,IAAI,CAACZ,aAAa,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAACU,cAAc;IAC3E,IAAI,CAACR,cAAc,GAAG;MAACW,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,CAAC;MAAEC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;IAAC,CAAC;IACjD,IAAI,CAACZ,QAAQ,GAAGZ,eAAe,CAAC,IAAI,CAACW,cAAc,EAAE,IAAI,CAACL,WAAW,EAAE,CACrE,IAAI,CAACe,oBAAoB,EAAE,IAAI,CAACZ,aAAa,CAAC,CAAC,CAAC,EAAE,IAAI,CAACA,aAAa,CAAC,CAAC,CAAC,CACxE,CAAC;IACF,IAAI,CAACI,SAAS,GAAG,YAAY;EAC/B;EAEAC,WAAWA,CAAA;IACT,MAAMC,QAAQ,8CAAAC,MAAA,CACsB,IAAI,CAACP,aAAa,CAAC,CAAC,CAAC,2CAAAO,MAAA,CAC1B,IAAI,CAACK,oBAAoB,oCAAAL,MAAA,CAC/B,IAAI,CAACG,cAAc,eAAAH,MAAA,CAE1CjB,IAAI,EAAE,q2BAAAiB,MAAA,CAuBFd,kBAAkB,0FAIrB;IACH,OAAOa,QAAQ;EACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}