{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getMainHeaderString as main } from './webgpu_program';\nimport { computeDispatch, flatDispatchLayout } from './webgpu_util';\nexport class Pool2DProgram {\n  constructor(convInfo, poolType) {\n    let computePositions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let flattenPositions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let includeBatchIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    this.variableNames = ['x'];\n    this.uniforms = \"strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,\";\n    // TODO(jiajia.qin@intel.com): Dynamically choose different workgroupSize for\n    // different output shapes.\n    this.workgroupSize = [128, 1, 1];\n    this.size = true;\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.poolType = poolType;\n    this.computePositions = computePositions;\n    this.flattenPositions = flattenPositions;\n    this.includeBatchIndex = includeBatchIndex;\n    this.shaderKey = \"pool2D_\".concat(poolType, \"_\").concat(computePositions, \"_\").concat(flattenPositions, \"_\").concat(includeBatchIndex);\n  }\n  getUserCode() {\n    let updateSnippet;\n    if (this.poolType === 'avg') {\n      updateSnippet = \"resultValue = resultValue + value; count = count + 1.0;\";\n    } else if (this.computePositions) {\n      const positionStr = this.flattenPositions ? this.includeBatchIndex ? \"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d\" : \"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d\" : \"wR * uniforms.filterDims.y + wC\";\n      updateSnippet = \"let currMaxValue = mix(value, maxValue, maxValueFound);\\n      if (value >= currMaxValue) {\\n        maxValue = value;\\n        maxValueFound = 1.0;\\n        maxPosition = \".concat(positionStr, \";\\n      }\");\n    } else {\n      updateSnippet = \"resultValue = max(value, resultValue);\";\n    }\n    let returnValue = \"resultValue\";\n    if (this.poolType === 'avg') {\n      returnValue = \"resultValue / max(count, 1.0)\";\n    }\n    const userCode = \"\\n      \".concat(main('index'), \" {\\n      if (index < uniforms.size) {\\n        let coords = getCoordsFromIndex(index);\\n          let batch = coords[0];\\n          let d = coords[3];\\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\\n          let xRCorner = xRCCorner.x;\\n          let xCCorner = xRCCorner.y;\\n\\n          \").concat(this.computePositions ? \"var maxValue = 0.0;\\n            var maxValueFound = 0.0;\\n            var maxPosition = 0;\" : \"var resultValue = \".concat(this.poolType === 'avg' ? '0.0' : '-1.0 / pow(10.0, -20.0)', \";\"), \"\\n\\n          var count = 0.0;\\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\\n            let xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= uniforms.convDims.x) {\\n              continue;\\n            }\\n\\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\\n              let xC = xCCorner + wC;\\n              if (xC < 0 || xC >= uniforms.convDims.y) {\\n                continue;\\n              }\\n\\n              let value = getX(batch, xR, xC, d);\\n              \").concat(updateSnippet, \"\\n            }\\n          }\\n\\n          \").concat(this.computePositions ? \"setOutputAtIndexI32(index, maxPosition);\" : \"setOutputAtIndex(index, \".concat(returnValue, \");\"), \"\\n        }\\n      }\\n    \");\n    return userCode;\n  }\n}\nexport class Pool3DProgram {\n  constructor(convInfo, poolType) {\n    let computePositions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let flattenPositions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let includeBatchIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    this.variableNames = ['x'];\n    this.uniforms = \"strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,\";\n    this.workgroupSize = [128, 1, 1];\n    this.size = true;\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);\n    this.poolType = poolType;\n    this.computePositions = computePositions;\n    this.flattenPositions = flattenPositions;\n    this.includeBatchIndex = includeBatchIndex;\n    this.shaderKey = \"pool3D_\".concat(poolType, \"_\").concat(computePositions, \"_\").concat(flattenPositions, \"_\").concat(includeBatchIndex);\n  }\n  getUserCode() {\n    let updateSnippet;\n    if (this.poolType === 'avg') {\n      updateSnippet = \"resultValue += value; count += 1.0;\";\n    } else if (this.computePositions) {\n      const positionStr = this.flattenPositions ? this.includeBatchIndex ? \"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch\" : \"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch\" : \"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC\";\n      updateSnippet = \"let currMaxValue = mix(value, maxValue, maxValueFound);\\n      if (value >= currMaxValue) {\\n        maxValue = value;\\n        maxValueFound = 1.0;\\n        maxPosition = \".concat(positionStr, \";\\n      }\");\n    } else {\n      updateSnippet = \"resultValue = max(value, resultValue);\";\n    }\n    let returnValue = \"resultValue\";\n    if (this.poolType === 'avg') {\n      returnValue = \"resultValue / max(count, 1.0)\";\n    }\n    const userCode = \"\\n      \".concat(main('index'), \" {\\n        if (index < uniforms.size) {\\n          let coords = getCoordsFromIndex(index);\\n          let batch = coords.x;\\n          let ch = coords.u;\\n\\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\\n          let xDCorner = xCorner.x;\\n          let xRCorner = xCorner.y;\\n          let xCCorner = xCorner.z;\\n\\n          \").concat(this.computePositions ? \"var maxValue = 0.0;\\n            var maxValueFound = 0.0;\\n            var maxPosition = 0;\" : \"var resultValue = \".concat(this.poolType === 'avg' ? '0.0' : '-1.0 / pow(10.0, -20.0)', \";\"), \"\\n\\n          var count = 0.0;\\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\\n            let xD = xDCorner + wD;\\n            if (xD < 0 || xD >= uniforms.convDims.x) {\\n              continue;\\n            }\\n\\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\\n              let xR = xRCorner + wR;\\n              if (xR < 0 || xR >= uniforms.convDims.y) {\\n                continue;\\n              }\\n\\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\\n                let xC = xCCorner + wC;\\n                if (xC < 0 || xC >= uniforms.convDims.z) {\\n                  continue;\\n                }\\n\\n                let value = getX(batch, xD, xR, xC, ch);\\n                \").concat(updateSnippet, \"\\n              }\\n            }\\n          }\\n\\n          \").concat(this.computePositions ? \"setOutputAtIndexI32(index, maxPosition);\" : \"setOutputAtIndex(index, \".concat(returnValue, \");\"), \"\\n        }\\n      }\\n    \");\n    return userCode;\n  }\n}","map":{"version":3,"names":["getMainHeaderString","main","computeDispatch","flatDispatchLayout","Pool2DProgram","constructor","convInfo","poolType","computePositions","arguments","length","undefined","flattenPositions","includeBatchIndex","variableNames","uniforms","workgroupSize","size","Error","outputShape","outShape","dispatchLayout","dispatch","shaderKey","concat","getUserCode","updateSnippet","positionStr","returnValue","userCode","Pool3DProgram"],"sources":["D:\\Fitness WebApp\\tfjs-backend-webgpu\\src\\pool_webgpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\nimport {getMainHeaderString as main, WebGPUProgram} from './webgpu_program';\nimport {computeDispatch, flatDispatchLayout} from './webgpu_util';\n\nexport class Pool2DProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms =\n      `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,`;\n  // TODO(jiajia.qin@intel.com): Dynamically choose different workgroupSize for\n  // different output shapes.\n  workgroupSize: [number, number, number] = [128, 1, 1];\n  poolType: 'max'|'avg';\n  size = true;\n  computePositions: boolean;\n  flattenPositions: boolean;\n  includeBatchIndex: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, poolType: 'max'|'avg',\n      computePositions = false, flattenPositions = false,\n      includeBatchIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n\n    this.poolType = poolType;\n    this.computePositions = computePositions;\n    this.flattenPositions = flattenPositions;\n    this.includeBatchIndex = includeBatchIndex;\n    this.shaderKey = `pool2D_${poolType}_${computePositions}_${\n        flattenPositions}_${includeBatchIndex}`;\n  }\n\n  getUserCode(): string {\n    let updateSnippet: string;\n    if (this.poolType === 'avg') {\n      updateSnippet = `resultValue = resultValue + value; count = count + 1.0;`;\n    } else if (this.computePositions) {\n      const positionStr = this.flattenPositions ?\n          (this.includeBatchIndex ?\n               `((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d` :\n               `(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d`) :\n          `wR * uniforms.filterDims.y + wC`;\n      updateSnippet = `let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${positionStr};\n      }`;\n    } else {\n      updateSnippet = `resultValue = max(value, resultValue);`;\n    }\n\n    let returnValue = `resultValue`;\n    if (this.poolType === 'avg') {\n      returnValue = `resultValue / max(count, 1.0)`;\n    }\n\n    const userCode = `\n      ${main('index')} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ${\n        this.computePositions ?\n            `var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;` :\n            `var resultValue = ${\n                this.poolType === 'avg' ? '0.0' : '-1.0 / pow(10.0, -20.0)'};`}\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ${updateSnippet}\n            }\n          }\n\n          ${\n        this.computePositions ? `setOutputAtIndexI32(index, maxPosition);` :\n                                `setOutputAtIndex(index, ${returnValue});`}\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n\nexport class Pool3DProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms =\n      `strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,`;\n  workgroupSize: [number, number, number] = [128, 1, 1];\n  poolType: 'max'|'avg';\n  size = true;\n  computePositions: boolean;\n  flattenPositions: boolean;\n  includeBatchIndex: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv3DInfo, poolType: 'max'|'avg',\n      computePositions = false, flattenPositions = false,\n      includeBatchIndex = false) {\n    if (poolType === 'avg' && computePositions) {\n      throw new Error('Cannot compute positions for average pool.');\n    }\n\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workgroupSize);\n\n    this.poolType = poolType;\n    this.computePositions = computePositions;\n    this.flattenPositions = flattenPositions;\n    this.includeBatchIndex = includeBatchIndex;\n    this.shaderKey = `pool3D_${poolType}_${computePositions}_${\n        flattenPositions}_${includeBatchIndex}`;\n  }\n\n  getUserCode(): string {\n    let updateSnippet: string;\n    if (this.poolType === 'avg') {\n      updateSnippet = `resultValue += value; count += 1.0;`;\n    } else if (this.computePositions) {\n      const positionStr = this.flattenPositions ?\n          (this.includeBatchIndex ?\n               `(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch` :\n               `((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch`) :\n          `wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC`;\n      updateSnippet = `let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${positionStr};\n      }`;\n    } else {\n      updateSnippet = `resultValue = max(value, resultValue);`;\n    }\n\n    let returnValue = `resultValue`;\n    if (this.poolType === 'avg') {\n      returnValue = `resultValue / max(count, 1.0)`;\n    }\n\n    const userCode = `\n      ${main('index')} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ${\n        this.computePositions ?\n            `var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;` :\n            `var resultValue = ${\n                this.poolType === 'avg' ? '0.0' : '-1.0 / pow(10.0, -20.0)'};`}\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ${updateSnippet}\n              }\n            }\n          }\n\n          ${\n        this.computePositions ? `setOutputAtIndexI32(index, maxPosition);` :\n                                `setOutputAtIndex(index, ${returnValue});`}\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}