{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Generates WGSL that computes strides.\nexport function symbolicallyComputeStrides(indicesArr, variableName) {\n  if (Math.max(...indicesArr) > 5) {\n    throw new Error('Cannot symbolically compute strides for rank > 6 tensor.');\n  }\n  const numCoords = indicesArr.length;\n  const indicesStr = 'xyzwuv';\n  const shape = indicesArr.map(d => \"\".concat(variableName, \".\").concat(indicesStr[d]));\n  const strides = new Array(numCoords - 1);\n  strides[numCoords - 2] = shape[numCoords - 1];\n  for (let i = numCoords - 3; i >= 0; --i) {\n    strides[i] = \"(\".concat(strides[i + 1], \" * \").concat(shape[i + 1], \")\");\n  }\n  return strides;\n}\nexport const atomicAddSnippet = (ptr, v, type) => {\n  if (type === 'int32') {\n    return \"atomicAdd(\".concat(ptr, \", bitcast<i32>(\").concat(v, \"));\");\n  } else {\n    // atomicAdd only supports uint/int type. For float, we use\n    // atomicCompareExchangeWeak to simulate.\n    return \"\\n          {\\n            var oldValue = 0;\\n            loop {\\n              let newValueF32 = bitcast<f32>(oldValue) + (\".concat(v, \");\\n              let newValue = bitcast<i32>(newValueF32);\\n              let res = atomicCompareExchangeWeak(\").concat(ptr, \", oldValue, newValue);\\n              if res.exchanged {\\n                break;\\n              }\\n              oldValue = res.old_value;\\n            }\\n          }\");\n  }\n};","map":{"version":3,"names":["symbolicallyComputeStrides","indicesArr","variableName","Math","max","Error","numCoords","length","indicesStr","shape","map","d","concat","strides","Array","i","atomicAddSnippet","ptr","v","type"],"sources":["D:\\Fitness WebApp\\tfjs-backend-webgpu\\src\\shader_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Generates WGSL that computes strides.\nexport function symbolicallyComputeStrides(\n    indicesArr: number[], variableName: string): string[] {\n  if (Math.max(...indicesArr) > 5) {\n    throw new Error('Cannot symbolically compute strides for rank > 6 tensor.');\n  }\n\n  const numCoords = indicesArr.length;\n  const indicesStr = 'xyzwuv';\n  const shape = indicesArr.map(d => `${variableName}.${indicesStr[d]}`);\n  const strides = new Array(numCoords - 1);\n  strides[numCoords - 2] = shape[numCoords - 1];\n  for (let i = numCoords - 3; i >= 0; --i) {\n    strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;\n  }\n\n  return strides;\n}\n\nexport const atomicAddSnippet =\n    (ptr: string, v: string, type: 'int32'|'float32') => {\n      if (type === 'int32') {\n        return `atomicAdd(${ptr}, bitcast<i32>(${v}));`;\n      } else {\n        // atomicAdd only supports uint/int type. For float, we use\n        // atomicCompareExchangeWeak to simulate.\n        return `\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${v});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${ptr}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`;\n      }\n    };\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA;AACA,OAAM,SAAUA,0BAA0BA,CACtCC,UAAoB,EAAEC,YAAoB;EAC5C,IAAIC,IAAI,CAACC,GAAG,CAAC,GAAGH,UAAU,CAAC,GAAG,CAAC,EAAE;IAC/B,MAAM,IAAII,KAAK,CAAC,0DAA0D,CAAC;;EAG7E,MAAMC,SAAS,GAAGL,UAAU,CAACM,MAAM;EACnC,MAAMC,UAAU,GAAG,QAAQ;EAC3B,MAAMC,KAAK,GAAGR,UAAU,CAACS,GAAG,CAACC,CAAC,OAAAC,MAAA,CAAOV,YAAY,OAAAU,MAAA,CAAIJ,UAAU,CAACG,CAAC,CAAC,CAAE,CAAC;EACrE,MAAME,OAAO,GAAG,IAAIC,KAAK,CAACR,SAAS,GAAG,CAAC,CAAC;EACxCO,OAAO,CAACP,SAAS,GAAG,CAAC,CAAC,GAAGG,KAAK,CAACH,SAAS,GAAG,CAAC,CAAC;EAC7C,KAAK,IAAIS,CAAC,GAAGT,SAAS,GAAG,CAAC,EAAES,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;IACvCF,OAAO,CAACE,CAAC,CAAC,OAAAH,MAAA,CAAOC,OAAO,CAACE,CAAC,GAAG,CAAC,CAAC,SAAAH,MAAA,CAAMH,KAAK,CAACM,CAAC,GAAG,CAAC,CAAC,MAAG;;EAGtD,OAAOF,OAAO;AAChB;AAEA,OAAO,MAAMG,gBAAgB,GACzBA,CAACC,GAAW,EAAEC,CAAS,EAAEC,IAAuB,KAAI;EAClD,IAAIA,IAAI,KAAK,OAAO,EAAE;IACpB,oBAAAP,MAAA,CAAoBK,GAAG,qBAAAL,MAAA,CAAkBM,CAAC;GAC3C,MAAM;IACL;IACA;IACA,sIAAAN,MAAA,CAIoDM,CAAC,qHAAAN,MAAA,CAETK,GAAG;;AAQnD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}